# AOP

비즈니스 로직에 필요한 부가기능을 독립적으로 모듈화하는 기술을 말한다.

**AOP의 장점**

- 비즈니스 로직에 추가되는 부가기능을 로직으로 부터 완전히 독립시킬 수 있다.
- 고립된 단위 테스트 코드 작성이 쉽다.

---

## 프록시(Proxy)

프록시는 클라이언트와 서버 사이에서 요청을 중계하는 객체를 말한다.  
Target 객체와 같은 인터페이스의 동일한 메소드를 구현해서 클라이언트의 요청이 Proxy Object를 통해서 Target에 접근하도록 한다.

![Screen Shot 2021-05-15 at 07 17 30 AM](https://user-images.githubusercontent.com/74804564/118336966-b9d84600-b54d-11eb-9785-e01053653d4d.png)

### 프록시를 이용하는 디자인 패턴

프록시를 사용하는 디자인 패턴에는 프록시 패턴과 데코레이터 패턴이 있다.  
두 패턴 모두 구현 방식은 프록시를 사용하지만 구현 목적에 따라서 구분해서 부른다.

- **프록시 패턴**
  Target에 대한 접근 요청에 대한 흐름을 제어하는 목적으로 사용한다.
  ex)

  1. Target에 진짜 필요한 순간에 Target을 생성하기 위해서
  2. 권한에 따른 접근을 제한하기 위해서
  3. 실제 처리에 직접적인 연관이 없지만 리소스가 드는 작업 (로깅, 백업 등등)
     <br>

- **데코레이터 패턴**
  Target에 대한 부가적인 기능을 추가하는 것을 목적으로 사용한다.
  ex)
  1. 트랜잭션 처리

---

## 리플렉션

클래스 타입을 알지 못해도 해당 클래스의 정보를 알 수 있도록 도와주는 Java API이다.
자바에서 클래스 자체를 추상화해서 접근할 수 있도록 해준다.  
취득한 클래스 정보를 사용해서 런타임 중에 동적으로 객체를 생성할 수 있다.

**리플렉션으로 알 수 있는 내용**

- 클래스명
- 접근제한자
- 패키지 정보
- 상속 클래스
- 구현 인터페이스
- 생성자
- 메소드
- 어노테이션

---

## 다이내믹 프록시

프록시 팩토리에 의해 런타임 중에 다이내믹 하게 프록시 객체를 만든다.  
프록시에서 필요한 부가기능은 InvocationHandler를 구현해서 처리한다.

```java
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
  getClass().getClassLoader(), // 다이내믹 클래스의 로딩에 사용할 클래스 로더
  new Class[] { Hello.class }, // 타깃 인터페이스
  new UppercaseHandler(new HelloTarget()) // InvocationHandler의 구현체와 타깃 객체
);
```

![Screen Shot 2021-05-15 at 08 51 29 AM](https://user-images.githubusercontent.com/74804564/118341618-c7e09380-b55a-11eb-80f2-3192afef6aad.png)

### 팩토리 빈

FactoryBean은 스프링을 대신해서 오브젝트를 생성할 수 있는 방법 중 하나이다.
FactoryBean 인터페이스를 구현하면 직접 빈으로 만들 수 있다.  
다이내믹 프록시는 런타임 중에 코드가 실행되면서 클래스가 정해지기 때문에 일반적인 방법으로는 스프링 빈에 등록할 수 없기 때문에 FactoryBean을 사용해서 빈으로 등록한다.

```java
public interface FactoryBean<T> {
  T getObject() throws Exception;
  Class<?> getObjectType();
  boolean isSingleton();
}
```

<br>

**프록시 팩토리 빈 방식의 장점**

1. 매번 Target이 구현하고 있는 인터페이스를 구현하는 프록시를 만들지 않아도 된다.
2. 여러 메소드에서 반복적으로 중복되는 코드를 작성해야하는 번거로움이 없다.

**프록시 팩토리 빈 방식의 단점**

1. 여러 개의 메소드에 대한 부가기능은 처리가 가능하지만 여러 클래스에 대한 처리는 불가능하다.
2. 부가기능의 개수만큼 빈 설정을 작성해야 한다는 번거로움이 있다.
