# 유연한 설계

## 개방 폐쇄 원칙 (OCP)

- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
  - 컴파일 타임 의존성은 코드에서 드러난 클래스들 사이의 관계
- 추상화가 핵심이다
  - 개방폐쇄 원칙의 핵심은 추상화에 의존하는 것
  - 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.
  - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다



## 생성 사용 분리

- 유연하고 재사용 가능한 설계를 위하여 객체와 관련한 두 가지 책임을 서로 다른 객체로 분리한다.
  - 객체를 **생성**하는 객체
  - 객체를 **사용**하는 객체
- 사용으로부터 생성을 분리하는데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것.



## 의존성 주입

- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후, 이를 전달해서 의존성을 해결하는 방법이 **의존성 주입**
- 의존성을 해결하는 세가지 방법
  - **생성자 주입** : 객체를 생성하는 시점에 생성자를 통한 의존성 해결
  - **setter 주입** : 객체 생성 후 setter 메서드를 통한 의존성 해결
    - 장점 : 의존성의 대상을 런타임에 변경할 수 있다.
    - 단점 : 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지 명시적으로 표현할 수 없다는 것.
  - **메서드 주입** : 메서드 실행 시 인자를 이용한 의존성 해결

- 숨겨진 의존성은 나쁘다. 명시적인 의존성이 숨겨진 의존성보다 낫다.



## 의존성 역전 원칙

- 하위 수준의 객체에 발생한 변경사항으로 인해 상위 수준의 객체가 영향을 받으면 안된다. 변경의 영향은 상위 수준의 객체에서 하위 수준의 객체로 흘러야 한다.

  - ~~~java
    class Movie {
       private AmountDiscountPolicy discountPolicy;
    }
    ~~~

  - 상위 수준의 객체 `Movie`는 하위 수준의 객체 `AmountDiscountPolicy`의 변경에 영향을 받는다. 잘못된 설계이다.

  - `Movie`가 `AmountDiscountPolicy`를 직접 의존해서 발생하는 문제이다. 추상화로 문제를 해결할 수 있다.

  - `DiscountPolicy`라는 인터페이스를 만들고, `AmountDiscountPolicy`가 이를 구현(implements)하고, `Movie`는 인터페이스를 의존하면, 하위 수준의 `AmountDiscountPolicy`의 변경사항으로 인해 Movie에 영향을 주는 일이 없어진다.

  - <mark>상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야 한다.</mark>



## 유연성에 대한 조언

- 유연한 설계는 유연성이 필요할 때만 옳다
- 협력과 책임이 중요하다
