# 오류 처리

- [오류 코드보다 예외를 사용하라](1)

- [Try-Catch-Finally 문부터 작성하라](2)

- [미확인 예외를 사용하라](3)

- [예외에 의미를 제공하라](4)

- [호출자를 고려해 예외 클래스를 정의하라](5)

- [null을 반환하지 마라](6)

- [null을 전달하지 마라](7)

## 오류 코드보다 예외를 사용하라<a name="1"></a>

- 오류를 반환할 경우, 호출부에서 이를 확인하고 대응해야 하므로, 에러대신 예외를 던지는것이 좋다.

## Try-Catch-Finally 문부터 작성하라<a name="2"></a>

- try 블록안에서 어떤 일이 발생하든 catch 블록은 일관성있어야 한다. 이런 면은 트랜잭션과 유사해보인다.

- try-catch 구조로 범위를 정의하고, TDD를 사용해 나머지 논리를 추가한다.

## 미확인 예외를 사용하라<a name="3"></a>

- 확인된 예외는 OCP를 위반한다.
  
  - 메소드에서 확인된 예외를 던졌는데, catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두 선언부에 해당 예외를 정의해야한다.
  
  - 즉 하위 단계에서 코드를 변경하면 상위 단계 메소드 선언부를 전부 고쳐야 한다.

## 예외에 의미를 제공하라<a name="4"></a>

- 오류 메시지에 정보를 담아 예외와 함께 던지자

- catch 블록에서 logging을 사용하는것도 좋은 방법

## 호출자를 고려해 예외 클래스를 정의하라<a name="5"></a>

- 예외 클래스를 생성할땐, 예외를 분류하듯 정의하기보다 호출부에서 예외를 처리하는 방법의 관점에서 예외 클래스를 정의해야한다.

```java
// Bad
try {
   port.open();
} catch (DeviceResponseException e) {
   reportPortError(e);
   logger.log("Device response expcetion", e);
} catch (ATM1212UnlockedException e) {
   reportPortError(e);
   logger.log("Unlock exception", e);
}

// Good
try {
   port.open();
} catch (DeviceResponseException e) {
   throw new PortDeviceFailure(e);
} catch (ATM1212UnlockedException e) {
   throw new PortDeviceFailure(e);
}
```

## null 을 반환하지 마라<a name="6"></a>

- `NullPointerException`이 발생할 상황을 만들지 말자

- <mark>null 확인을 자주 하기보다 null 이면 예외를 던지거나 특수 객체를 반환하는 방식</mark>을 고려해보자.

```java
// 이 코드는 getEmployee에서 null을 반환하는데, 이 경우엔 굳이 null을 반환할 필요가 없다.
List<Employee> employees = getEmployees();
if (employees != null) {
  for(Employee e: employees) {
    totalPay += e.getPay(;)
  }
}


// null 대신 빈 리스트를 반환하는것이 더 깔끔하다
List<Employee> employees = getEmployees();
for(Employee e : employees) {
   totalPay += e.getPay();
}
```

- 이렇게 코드를 변경하면 `NullPointerException`이 발생할 가능성이 낮아진다.

## null을 전달하지 마라<a name="7"></a>

- 메소드에서 null을 반환하는것보다 더 나쁜게 메소드로 null을 전달하는 것.
