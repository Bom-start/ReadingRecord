# 스프링 MVC

## 컨트롤러

컨트롤러는 MVC의 3가지 컴포넌트 중에서 가장 많은 책임을 지고 있다.  
이런 많은 책임을 하나의 메소드에서 처리하는 것 비효율적이고 객체지향 적이지 않다.  
역할과 책임을 성격과 특징, 변경 사유 등을 기준으로 세분화해줄 필요가 있다.

**컨트롤러의 책임**

- 클라이언트의 요청을 파악(호스트, 포트, URI, 쿼리 스트링, 폼 파라미터, 쿠키, 헤더, 세션 등...)
- 올바른 요청인지 검증
- 요청을 처리하는 중 발생한 예외를 처리
- HttpServletRequest를 적절한 타입으로 변환하거나 가공
- 서비스 계층의 메소드를 선정하고 호출
- 요청에 대한 결과를 어떤 뷰를 통해서 보여줘야 하는지 결정
- 필요에 따라 상태를 세션에 저장

### 컨트롤러와 핸들러 어댑터의 종류

Http 요청에 대한 처리를 담당한다.  
스프링 MVC의 컨트롤러는 적절한 핸들러 어댑터만 같이 구현한다면 타입의 상관없이 확장이 가능하다.

1. **Servlet ↔ SimpleServletHandlerAdapter**

   - 표준 Servlet 타입의 컨트롤러를 사용 가능
   - Servlet으로 작성된 코드를 점진적으로 스프링에 맞게 포팅할 때 유용
   - Servlet의 init(), destroy()와 같은 생명주기 메소드는 호출되지 않음 (<bean> 태그의 init-method나 @PostConstruct 등을 이용해야한다.)
   - Model과 View를 리턴하지 않는다. (HttpServletRespons을 사용)
   - SimpleServletHandlerAdapter는 디폴트 전략 X

1. **HttpRequestHandler ↔ HttpRequestHandlerAdapter**

   - 서블릿 처럼 동작하는 컨트롤러를 만들기 위해서 사용
   - 모델과 뷰 개념이 없는 HTTP 기반의 RMI와 같은 로우레벨 서비스를 개발할 때 이용
   - HttpRequestHandlerAdapter는 디폴트 전략

1. **Controller ↔ SimpleControllerHandlerAdapter**

   - 스프링 MVC의 가장 대표적인 컨트롤러 타입
   - 보통 직접 구현해서 사용하지 않고 기본적인 기능을 수행하는 기반 컨트롤 클래스를 만들고 상속을 받아서 사용
   - SimpleControllerHandlerAdapter는 디폴트 전략

1. **AnnotationMethodHandlerAdapter**
   - 클래스와 메소드에 붙은 몇 가지 애노테이션의 정보와 메소드 이름, 파라미터, 리턴 타입에 대한 규칙을 가지고 컨트롤러를 선별
   - 하나의 컨트롤러가 하나 이상의 URL에 매핑될 수 있다는 장점
   - 컨트롤러의 단위가 클래스가 아닌 메소드 단위로 가능
   - DefaultAnnotationHandlerMapping 핸들러 매핑과 함께 사용해야 한다.
   - AnnotationMethodHandlerAdapter는 디폴트 전략

### 핸들러 매핑 종류

여러가지 컨트롤러 중 HTTP 요청을 처리할 컨트롤러를 찾아주는 기능을 담당한다.

1. **BeanNameUrlHandlerMapping**

   - 요청 URL과 비교해서 일치하는 빈을 찾는다.
   - ANT 패턴(\*, \*\*, ?)을 사용할 수 있다.
   - 디폴트 매핑

2. **ControllerBeanNameHandlerMapping**

   - 컨트롤러 빈의 아이디나 이름을 이용해서 찾는다.
   - XML에 정의하는 경우 빈의 아이디에 /를 붙여준다.
   - prefix, suffix를 지정할 수 있다.

3. **ControllerClassNameHandlerMapping**

   - 빈 이름 대신 클래스 이름을 URL 매핑에 활용
   - 클래스 이름이 Controller로 끝날 때는 Controller를 밴 나머지 이름을 URL에 매핑

4. **SimpleUrlHandlerMapping**

   - 매핑정보를 하곳에 작성해서 빈 이름이나 아이디에 매핑정보를 넣는 불편함을 해소

5. **DefaultAnnotationHandlerMapping**
   - @RequestMapping이라는 애노테이션을 컨트롤러 클래스나 메소드에 부여해서 매핑
   - 메소드 단위로 매핑해줄 수 있어 컨트롤러 크래스의 개수를 획기적으로 줄일 수 있다는 장점
   - 디폴트 매핑

**공통 설정정보**

- order

  핸들러 매핑을 한 개 이상 동시에 사용할 수 있는데 URL 매핑 정보가 중복되는 경우 우선순위를 지정할 수 있다.

- defaultHandler

  핸들러 매핑 빈에 defaultHandler 프로퍼티를 지정해두면 URL 매핑 대상이 없을 때 자동으로 defaultHandler를 선택해 준다.

- alwaysUseFullPath

  컨택스트 패스와 서블릿 패스 두 가지를 모두 포함한 URL 전체를 사용해서 컨트롤러를 매핑할 수 있다.

- detectHandlerInAncestorContexts
  핸들러 매핑 클래스를 현재 속한 서블릿 컨텍스트 안에서 찾고 없으면 루트 컨텍스트에서 컨트롤러를 찾도록 할 수 있다.

### 핸들러 인터셉터

DispatcherServlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터 역할

컨트롤러에 AOP를 적용할수는 있지만 컨트롤러의 타입이 정해져 있지 않고, 실행 메소드의 이름이나 파라미터도 재각각이라서 포인트 컷을 작성하기 쉽지 않다. 때문에 컨트롤러 실행 전 후에 부가적인 작업이 필요한 경우 AOP보다는 인터셉터를 사용한다.

HandlerInterceptor 인터페이스 메소드

- preHandle : 컨트롤러 호출 전에 실행
- postHandle : 컨트롤러 호출 후에 실행
- afterCompletion : 뷰에서 최종 결과를 생성하는 일을 포함해서 모든 작업이 완료된 다음에 실행

## 뷰

컨트롤러가 작업을 마치고 DispatcherServlet한테 ModelAndView 오브젝트를 전달한다.

ModelAndView를 통해서 뷰 정보를 전달하는 방법에는 2가지가 있다.

1. View 타입의 오브젝트를 전달
2. **뷰의 이름을 전달 (이 경우 실제 사용할 뷰를 결정할 뷰 리졸버가 필요)**

### 뷰 종류

1. InternalResourceView
   - RequestDispatcher의 forward()나 include()를 이용하는 뷰
   - 주로 JSP 뷰로 포워딩할 때 사용
2. JstlView
   - InternalResourceView의 서브 클래스
   - 지역정보(Locale)에 따라 달리지는 메시지를 JSP 뷰에서 사용할 수 있게 해준다.
3. RedirectView
   - HttpServletResponse의 sendRedirect()를 호출해주는 기능을 가진 뷰
   - 뷰의 이름을 반환할 경우 앞에 redirect: 접두어를 사용
4. VelocityView, FreeMarkerView
   - 벨로시티와 프리마커 템플릿 엔진을 뷰로 사용하게 해준다.
5. MarshallingView
   - OXM 추상화 기능을 활용해서 XML 콘텐트를 작성하게 해주는 뷰
6. AbstractExcelView, AbstractJExcelView, AbstractPdfView
   - 엑셀과 PDF 문서를 만들어주는 뷰
7. AbstractAtomFeedView, AbstractRssFeedView
   - application/atom+xml과 application/rss+xml 타입의 feed 문서를 생성해주는 뷰
8. MappingJacksonJsonView
   - AJAX에서 많이 사용되는 JSON 타입의 콘텐트를 작성해주는 뷰
