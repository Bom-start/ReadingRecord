# 스프링의 기타 기술과 효과적인 학습 방법

## 효과적인 학습 방법

스프링은 DI를 지원하는 프레임워크이면서 자신도 DI를 적극 활용하여 만들어 졌다.  
DI의 가치를 가장 잘 발견할 수 있고, 증명하고 있는 것이 스프링이다.

### 빈으로 등록된다는 의미

**1. 다른 빈에 의해 DI 돼서 사용되는 서비스라는 의미**

    빈으로 등록되었다는 것은 적어도 한 개 이상의 빈과 의존관계를 갖는다는 뜻
    (독립적인 객체는 빈으로 등록될필요가 없다.)

**2. 다른 빈이나 정보에 의존하고 있다는 의미**

    대부분 빈은 자신이 클라이언트가 되어서 다른 빈을 사용한다.
    꼭 빈이 아니더라도 의미있는 정보에 의존하고 있기도 하다.

### 빈 분석 방법

#### 1. 구현 인터페이스 분석

빈이 구현한 인터페이스는 사용하려는 클라이언트와의 연결 채널이다.  
구현한 인터페이스를 확인하면 빈이 맺고 있는 관계를 파악하거나 제공하는 기능을 파악할 수 있다.  
스프링 API 문서를 찾아보거나, IDE에서 클래스의 타입 계증구조를 보는 기능을 이용한다.

#### 2. 프로퍼티 분석

빈의 프로퍼티를 보면 동작방식을 이해하는 데 도움이 된다.

#### 3. DI/확장 포인트 분석

프로퍼티 중에서 인터페이스 타입의 프로퍼티는 확장 포인트라고 생각하면 된다.

<br/>

---

<br/>

## 스프링의 기타 기술

### 1. 후처리기

애플리케이션 컨텍스트도 그 자체로 빈은 아지만 DI를 받는다.  
BeanPostProcessor, BeanFactoryPostProcessor 인터페이스를 구현한 빈을 찾아서 스스로 DI 한다.

#### BeanPostProcessor

- 빈 후처리기
- 빈 오브젝트가 처음 만들어지고, 초기화 메소드가 호출되기 전에 실행
- 빈 오브젝트를 바꿔치기, 기본 설정과 다른 새로운 기능을 부여, 설정에 없는 프로퍼티 값 설정 등의 작업을 할 수 있다.
- 대표적인 기능으로 애노테이션을 이용한 빈 의존관계 (@Autowired, @Inject), AOP 자동 프록시 생성기가 있다.

#### BeanFactoryPostProcessor

- 빈 팩토리 후처리기
- 빈 설정 메타데이터가 준비된 시점에 실행
- 빈의 메타정보를 수정, 프로퍼티 값 추가, 새로운 빈을 등록 등의 작업을 할 수 있다.
- 대표적이 기능으로 애노테이션을 이용한 빈 등록(@Configuration, @Bean)이 있다.

<br/>

### 2. SpEL

3.0 버전부터 지원하는 스프링 전용 표현식 언어(EL)  
자바 코드를 사용하기 힘든 XML, JSP, 애노테이션 값 등에서 유용하게 사용 가능  
기본적으로 빈 설정 파일이나 애노테이션에서 프로퍼티 값을 지정할 때나 \<spring:eval\> 태그에서 사용한다.

#### ExpressionParser

- 표현식을 파싱하는 기능이 정의되어 있는 인터페이스
- 주로 SpelExpressionParser 클래스를 사용
- 싱글톤으로 사용되어도 안전 (빈으로 등록 가능)

#### Expression

- 파싱 결과 값을 가지는 오브젝트
- 파싱 결과를 재사용 하기 위해서 Expression 타입에 오브젝트를 사용

<br/>

### 3. OXM (Object XML Mapping)

XML과 오브젝트를 변환해주는 기술 (XML -> 오브젝트, 오브젝트 -> XML)  
OXM 기술은 적용하기 전에 충분한 학습과 이해가 필요하다.  
주로 XML와 오브젝트 사이의 변경 작업을 수행하거나 웹 환경에서 XML 뷰, XML 메시지 컨버터를 만들 때 활용한다.  
(MarshallingView, MarshallingMessageConverter)

#### Marshaller/Unmarshaller

- Marshaller는 오브젝트에서 XML로 변환하는 기능을 추상화한 인터페이스
- Unmarshaller는 XML에서 오브젝트로 변환하는 기능을 추상화한 인터페이스

#### OXM 기술 어댑터 클래스

- Marshaller/Unmarshaller 두 인터페이스를 구현해서 각 OXM 기술들과 연결 시키는 어댑터 클래스를 제공
- Castor, JAXB, XMLBeans, JiBX, XStream (각 기술 뒤에 Marshaller를 붙이면 지원 클래스이다.)
- 어댑터 클래스는 Marshaller/Unmarshaller 두 인터페이스를 모두 구현하고 있다.

<br/>

### 4. 리모팅

스프링 애플리케이션이 원격 서비스를 제공하거나, 다른 원격 시스템의 서비스를 이용하는 기술  
원격 서비스를 제공할 때나 제공 사용할 때나 모두 인터페이스를 이용해야 함  
기본적인 구성은 RESTful 방식을 제외하면 거의 동일

#### 익스포터

- 원격 서비스를 제공하는 빈
- 서비스 인터페이스를 구현한 서비스 빈에게 클라이언트 요청을 전달 해주는 빈
- 마치 클라이언트의 오브젝트인 것처럼 서비스를 제공하는 빈을 인터페이스를 통해서 호출

#### 프록시

- 원격 서비스를 사용하는 빈
- 클라이언트 오브젝트의 요청을 원격 오브젝트에게 전송해서 결과를 받아오는 역할의 빈
- 원격 서비스의 내용이 정의된 인터페이스를 구현하고 있어야 한다.

#### RESTful 서비스 템플릿

- 익스포터, 프록시를 이용한 리모팅 기술과는 사용 방법이 다름
- 원격 RESTful 서비스 사이트를 통해서 결과를 가져오는 클라이언트 기능만 제공
- 원격 프록시 패턴 대신 템플릿/콜백 방식의 템플릿을 이용
- RestTemplate을 빈으로 등록해서 사용
- RestTemplate의 messageConverts 프로퍼티로 메시지 컨버터를 등록해서 XML, JSON 타입의 오브젝트로 결과를 받을 수도 있다.

#### EJB 서비스 이용

- EJB 컨테이너에서 서비스되고 있어도 스프링에서 사용할 수 있다.
- jee 스키마의 local-slsb, remote-slsb 태그를 사용

<br/>

### 5. Task

독립적인 스레드 안에서 동작하도록 만들어진 오브젝트  
java.lang.Runnable

#### TaskExecutor

- 스프링은 태스크를 다양한 방법으로 실행하도록 추상화한 TaskExecutor라는 인터페이스를 제공한다.
- ThreadPoolExecutor, SimpleThreadPoolTaskExecutor, WorkManagerTaskExecutor

```java
public interface TaskExecutor extends Executor {
    void execute(Runnable task);
}
```

#### TaskScheduler

- 앤터프라이즈 환경에서 태스크는 일정한 시간 기준에 따라서 실행되는 스케줄링 방식으로 동작하는 경우가 대부분이다.
- 스프링은 스케줄링 기술에 독립적인 사용이 가능한 추상화 인터페이스 TaskScheduler를 제공한다.
- 태스크를 조건에 따라 실행하거나 반복하는 작업을 수행
- Trigger 인터페이스를 구현해서 좀 더 유연한 실행조건을 만들 수도 있다.

#### task 네임스페이스

- task 스키마에 정의된 전용 태그로 TaskExecutor와 TaskScheduler를 간편하게 등록할 수 있는 방법을 제공
- \<task:executor\>
- \<task:scheduler\>
- \<task:scheduled-tasks\>, \<task:scheduled\>
  - 태스크마다 Runnable을 구현해서 빈으로 등록하고, 스케줄 등록 코드를 작성하는 번거로움을 해소
  - 일반 빈의 메소드를 태스크로 활용

#### 애노테이션을 이용

- 애노테이션을 이용한 방법도 제공
- @Scheduled
- @Async
  - @Async 메소드는 TaskExecutor를 사용하지 않아도 자동으로 비동기 방식으로 실행

<br/>

### 3. 캐시

성능 향상의 목적으로 동일한 결과를 리턴하지만 반복적인 작업이 많고, 작업의 시간이 오래 걸리거나 서버에 부담을 주는 메소드의 결과를 임시 저장소에 저장해두고 재활용하는 것

#### 캐시 애노테이션

- 스프링은 캐시 기능을 적용할 수 있는 AOP 어드바이스를 제공한다.
- 애노테이션을 이용한 캐시 기능을 사용하려면 \<cache:annotation-driven \/\>나 @EnableChaching 가 필요하다.
- @Cacheable, @CacheEvict, @CachePut

#### 캐시 매니저

- 적용할 캐시 기능을 선정할 수 있는 서비스 추상화를 제공 (CacheManager 인터페이스)
- 스프링 3.1에서 기본적으로 5가지의 구현 클래스를 제공
  - **ConcurrentMapCacheManager**
    - 캐시의 양이 많지 않고 고급 기능이 필요하지 않은 경우나 테스트 용도로만 사용
  - **SimpleCacheManager**
    - 캐시가 없다. 직접 Cache 인터페이스를 구현할 때 테스트의 목적으로 사용
  - **EhCacheCacheManager**
    - 가장 인기 있는 캐시 프레임워크
  - **CompositeCacheManager**
    - 하나 이상의 캐시 매니저를 사용하도록 지원해 주는 혼합 캐시 매니저
  - **NoOpCacheManager**
    - 캐시가 지원되지 않는 환경에서 동작할 때 캐시 관련 설정을 제거하지 않아도 에러가 나지 않게 해주는 기능

<br/>

### 빈 설정 모듈화

빈 설정에서도 재사용이 가능한 설정 정보를 모듈화한다.  
스프링 3.1에서는 @Enable 설정 애노테이션과 자바 코드를 이용한 설정 방법을 제공한다.

- **@Import**
  - 다른 @Configuration 클래스를 추가
- **@Configuration 클래스 상속과 오버라이딩**
  - 한 개의 클래스만 상속할 수 있다는 단점이 있음
- **@Enable**
  - 보통 애노테이션 이름이 @Enable로 시작하는 애노테이션
  - 모듈화된 빈 설정 정보를 추가하면서 엘리먼트 값을 이용해 옵션 정보를 제공할 수 있게 해준다.
  - @Import를 메타 애노테이션으로 가진다.
  - **ImportAware 인터페이스**
    - @Enable 애노테이션 엘리먼트 정보에 따라 빈 설정 정보를 변경할 수 있도록 해준다.
  - **빈 설정자**
    - 재사용하려는 빈 설정 정보의 양이 많거나 확장 방법이 복합한 경우에 사용하는 방법
- **ImportSelector**
  - 상황에 따라 재사용하려는 @Configuration 클래스가 전혀 다른 경우 사용
