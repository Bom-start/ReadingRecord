## 3.5 기타 전략

-  핸들러 예외 리졸버
-  지역정보 리졸버
-  멀티파트 리졸버

---

### 핸들러 예외 리졸버

-  `HandlerExceptionResolver`는 컨트롤러의 작업중 발생한 예외를 어떻게 처리할지 결정하는 전략

-  컨트롤러나 그 뒤의 계층에서 던져진 예외는 `DispatcherServlet`이 전달받은 뒤 서블릿 컨테이너가 처리하지만 예외처리를 하는 핸들러 예외 리졸버가 있다면 예외는 `DispatcherServlet` 밖으로 던지지 않고 핸들러 예외 리졸버에서 처리한다.

-  스프링에서 제공하는 핸들러 예외 리졸버는 4가지이다.
   -  AnnotationMethodHandlerExceptionResolver
   -  ResponseStatusExceptionResolver
   -  DefaultHandlerExceptionResolver
   -  SimpleMappingExceptionResolver

#### AnnotationMethodHanlderExceptionResolver

-  예외가 발생한 컨트롤러 내의 메소드 중에 `@ExceptionHandler` 애노테이션이 붙은 메소드를 찾아 예외처리를 맡겨주는 핸들러 예외 리졸버
-  특정 컨트롤러의 작업 중에 발생하는 예외만 처리하는 예외 핸들러를 만들고 싶다면 이 방법이 가장 편리하다.

~~~java
@Controller
public class HellloController {
  @RequestMapping("/hello")
  public void hello() {
     ...
  }
  @ExcetionHandler(DataAccessException.class)
  public ModelAndView dataAccessExceptionHAndler(DataAccessException ex) {
    return new ModelAndView("dataException").addObject("msg", ex.getMessage());
  }
}
~~~

-  `DataAccessException`이 발생하면, `ExceptionHandler`가 붙은 메소드가 실행되며 `ModelAndView`를 반환한다. 

#### ResponseStatusExceptionResolver

-  예외를 특정 HTTP 응답 상태 코드로 전환해준다.
-  특정 예외가 발생했을 때 HTTP Status code 500 대신 의미있는 HTTP 응답 상태를 돌려주는 핸들러 예외처리 리졸버이다.
-  예외 클래스에 `@ResponseStatus`를 붙이고, `HttpStatus`에 자세한 설명을 넣을 수 있다.

~~~java
@ResponseStatus(value=HttpStatus.SERVICE_UNAVAILABLE, reason="서비스 일시 중지")
public class NotInServiceException extends RuntimeException {
  ...
}
~~~

-  위의 클래스는 서비스 계층이나 컨트롤러에서 특별한 이유로 작업을 더 이상 진행할 수 없는 경우에 던질 수 있다.
-  `ResponseStatusExceptionResolver`는 발생한 예외 클래스에 `@ResponseStatus`가 있는지 확인하고, 있다면 애노테이션에 지정해둔 HTTP 응답 상태 코드를 클라이언트에 전달
-  이때 사용자가 만나는 메세지가 애노테이션의 파라미터값.
   -  'HTTP 503 Service Unavailable - 서비스 일시중지'
-  만약 `@ResponseStatus`를 직접 부여할 수 없는 기존의 예외가 발생했을때 HTTP 응답 상태를 지정해주려면 `@ExceptionHandler` 방식의 핸들러 메소드를 사용한다.

#### DefaultHandlerExceptionResolver

-  스프링에서 내부적으로 발생하는 주요 예외를 처리하는 표준 예외처리 로직을 담는 핸들러 예외 리졸버
   -  ex 1) 컨트롤러 메소드를 찾을 수 없을때 `NoSuchRequestHandlingMethodException` 예외가 발생하면 HTTP 404 - Not Found를 응답상태로 지정,
   -  `TypeMismatchException`은 HTTP 400 - Bad Request 응답상태로 돌려준다.

#### SimpleMappingExceptionResolver

-  예외를 처리할 뷰를 지정해주는 핸들러 예외 리졸버
-  xml 로 처리하는 리졸버
-  `defaultErrorView` 프로퍼티는 `mappedHandlers`에서 찾을 수 없는 예외에 매핑해주는 디폴트 예외처리 뷰 이름이다.
-  디폴트 예외처리 전략이 아니므로 직접 빈으로 등록해서 사용해야 한다.
-  그러나 위의 3가지 디폴트 전략보다 더 편리한게 `SimpleMappingExceptionResolver` 이다.
-  HTTP 상태 코드를 예외 메세지와 함께 응답하는것보다 예외 페이지를 뷰로 전달해주는것이 더 좋기 때문이다.

### 지역 정보 리졸버

-  `LocaleResolver`는 애플리케이션에서 사용하는 지역정보(Locale)를 결정하는 전략
-  디폴트로 사용되는 `AcceptHeaderLocaleResolver`는 HTTP 헤더의 지역정보를 그대로 사용한다.
-  브라우저의 설정에따라 HTTP 헤더의 지역정보가 응답되는데, 이 브라우저의 설정을 변경하여 HTTP 요청의 지역정보를 변경할 수 있다.
-  HTTP 헤더 대신 HTTP 세션이나 쿠키에 들어있는 값을 확인해서 애플리케이션의 지역정보를 결정할 수도 있다. 이럴 경우 브라우저의 설정에 의존하지 않을 수 있다.

### 멀티 파트 리졸버

-  파일 업로드와 같은 멀티파트 포맷의 요청정보를 처리하는 전략을 설정하는 핸들러 예외 리졸버
-  디폴트로 등록된 리졸버 전략이 없고, Apache Commons의 FileUpload 라이브러리를 사용하는 `CommonsMultipartResolver` 한 가지만 지원한다.

~~~java
public ModelAndView handlerRequest(HttpServletRequest request, HttpServletResponse response) {
  MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest)request;
  MultipartFile multipartFile = multipartRequest.getFile("image");
}
~~~

-  `MultipartHttpServletRequest`에는 멀티파트를 디코딩한 내용과 이를 참조하거나 조작할 수 있는 기능이 추가되어 있다.
-  클라이언트로부터 멀티파크 요청을 받으면, `DispatcherSerlvet`은 멀티파트 리졸버에게 요청해서 `HttpServletRequest`의 확장 타입인 `MultipartHttpServletRequest` 오브젝트로 전환한다.

##### RequestToViewNameTranslator

-  컨트롤러에서 뷰 이름이나 뷰 오브젝트를 돌려주지 않을경우 HTTP 요청정보를 참고해서 뷰 이름을 생성해주는 로직을 담고있다.
-  `DefaultRequestToViewNameTranslator`를 디폴트 전략으로 등록한다.
-  `DefaultRequestToViewNameTranslator`는 URL을 기준으로 해서 뷰 이름을 결정한다.

<br>

## 3.6 스프링 3.1의 MVC

-  플래시 맵 매니저 전략
-  WebApplicationInitializer를 이용한 컨텍스트 등록

---

### 플래시 맵 매니저 전략

-  플래시 맵
   -  플래시 애트리뷰트를 저장하는 맵
      -  플래시 애트리뷰트란, 하나의 요청에서 생성되어 다음 요청으로 전달되는 정보를 말한다.
      -  플래시 애트리뷰트는 일반 HTTP 세션에 저장되는 정보처럼 오래 유지되지 않는다. 다음 요청에서 한 번 사용되고 바로 제거된다.
   -  플래시 애트리뷰트는 Post/Redirect/Get 패턴을 적용하는 경우에 사용된다.
      -  POST 단계에서 처리된 결과를 보여주는 "성공적으로 저장됐습니다." 같은 메시지를 GET 요청으로 출력되는 페이지에 작업 직후 한 번만 출력하는 용도
      -  이런 메시지는 반복되서 출력되면 안되기 때문
   -  플래시 맵은 여러 개의 애트리뷰트를 저장할 수 있도록 Map 타입으로 되어 있고, 플래시 애트리뷰트가 사용될 URL 조건과 제한시간을 지정할 수 있다.

### WebApplicationIntializer를 이용한 컨텍스트 등록

-  스프링 3.0이 web.xml 만을 이용하여 웹 애플리케이션 구성을 설정했던것과 달리 스프링 3.1에서는 ServletContainerInitializer를 이용하여 스프링 컨텍스트 설정과 등록 작업에 자바 코드를 이용할 수 있다.

~~~java
AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
servletContext.scan("com.mycompany.myproject.config");

ServletContextListener listener = new ContextLoaderListener(ac);
servletContext.addListener(listener);
~~~

<br>