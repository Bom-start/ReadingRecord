# ToC

- 1장 IoC 컨테이너와 DI
  - [1.1장 IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트](#1-1)
  - [1.2장 IoC/DI를 위한 빈 설정 메타정보 작성](#1-2)
  - [1.3장 프로토타입과 스코프](#1-3)
  - [1.4장 기타 빈 설정 메타정보](#1-4)
  - [1.5장 스프링 3.1의 IoC 컨테이너와 DI](#1-5)
- 2장 데이터 액세스 기술
  - [2.1장 공통개념](#2-1)
  - [2-2장. JDBC](#2-2)
  - [2-3장. iBatis SqlMaps](#2-3)

---

# <a name="1-1"></a>1.1장 IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트

스프링에서 제어권을 가지는 주체를 스프링 컨테이너라고 한다. 오브젝트의 생성과 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드가 아닌 이 스프링 컨테이너에서 담당한다. 그래서 이 컨테이너를 IoC 컨테이너라고 부른다.

스프링에선 IoC 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고도 부른다.

오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 스프링 컨테이너를 빈 팩토리(`BeanFactory`)라고 부른다. 그러나 스프링 컨테이너는 단순한 DI를 넘어 다양한 역할을 수행하므로 DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는데 필요한 여러가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트(`ApplicationContext`)라고 부른다. 

애플리케이션 컨텍스트는 IoC와 DI를 위한 빈 팩토리이면서 더 많은 기능을 가졌다고 이해하면 된다.

실제로도 빈팩토리와 애플리케이션 컨텍스트는 스프링에서 인터페이스로 정의되어 있는데, 애플리케이션 컨텍스트는 빈팩토리 인터페이스를 상속하는 인터페이스이다.

~~~java
public interface ApplicationContext extends ListableBeanFactory, HierachicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { }
~~~

이 `ApplicationContext`를 구현한 클래스의 오브젝트를 스프링 컨테이너 또는 IoC 컨테이너라고 부른다.

## IoC 컨테이너를 이용해 애플리케이션 만들기

![클래스 다이어그램](https://user-images.githubusercontent.com/33862991/123971471-08a24800-d9f5-11eb-953d-6c94e1acb184.png)

**요구사항**

- POJO 클래스를 이용한다.
- 메세지를 생성하여 메세지를 받아서 출력하는 프로그램을 개발한다.

**Hello.class**

~~~java
public class Hello {
   String name;
   Printer printer;
  
   public String sayHello() {
      return "Hello "+name;
   }
  
   public void print() {
      this.printer.print(sayHello());
   }
  
   public void setName(String name) {
      this.name = name;
   }
  
   public void setPrinter(Printer printer) {
      this.printer = printer;
   }
}
~~~

**Printer.class**

~~~java
public interface Printer {
   void print(String message);
}
~~~

**StringBuffer.class (StringBuffer를 사용한 Printer 구현 클래스)** 

~~~java
public class StringPrinter implements Printer {
   private StringBuffer buffer = new StringBuffer();
  
   public void print(String message) {
      this.buffer.append(message);
   }
  
   public String toString() {
      return this.buffer.toString();
   }
}
~~~

**ConsolePrinter.class (Console 출력 방식의 Printer 구현 클래스)**

~~~java
public class ConsolePrinter implements Printer {
   public void print(String message) {
      System.out.println(message);
   }
}
~~~



**코드 설명**

`Hello` 클래스는 `Printer`라는 인터페이스를 의존한다. 런타임시에 실제로 어떤 오브젝트를 사용할지를 알지 못한다. 

`Printer` 인터페이스는 두가지 구현 객체가 존재한다. `StringBuffer`를 이용해서 출력하는 클래스와 `Console`에 출력하는 클래스이다.



**설정 메타정보**

스프링의 설정 메타정보는 XML 파일이 아니다. XML에 담긴 내용을 읽어서 설정 메타정보로 활용하는건 맞지만, 스프링이 갖고있는 설정 메타정보가 XML 파일은 아니다.

스프링의 메타 정보는 `BeanDefinition` 인터페이스로 표현되는 순수한 추상정보이다. 파일의 포맷과 상관없이 스프링의 설정 메타정보의 내용을 표현했다면 무엇이든 사용가능하다. 데이터의 포맷과 구조에 맞게 읽어와 `BeanDefinition` 오브젝트로 변환하는 `BeanDefinitionReader`가 있으면 되기 때문이다.

스프링 IoC 컨테이너는 이 `BeanDefinition` 으로 만들어진 메타 정보를 담은 오브젝트를 사용하여 IoC와 DI 작업을 수행한다.

`BeanDefinition`에서 정의되는 빈 메타정보는 다음과 같다.

- 빈 아이디, 이름 : 빈 오브젝트를 구분하는 식별자
- 클래스, 클래스 이름 : 빈으로 만들 POJO 클래스 정보
- 스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
- 생성자 파라미터 값 또는 참조  : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연된 로딩 여부, 우선 빈 여부, 부모 빈 정보, 빈팩토리 이름 등



![IoC 컨테이너를 통해 애플리케이션이 만들어지는 방식](https://user-images.githubusercontent.com/33862991/123978272-b19f7180-d9fa-11eb-9d3a-7db0aa644f40.png)

스프링 애플리케이션은 POJO 클래스와 설정 메타정보를 이용하여 IoC 컨테이너가 만들어주는 오브젝트의 조합이라 할 수 있다.

**BeanDefinition을 이용한 빈 등록**

~~~java
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
~~~

**빈 등록 테스트**

~~~java
Hello hello = ac.getBean("hello", Hello.class);

assertThat(hello.sayHello(), is("Hello Spring"));
assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(1));
~~~



## IoC 컨테이너의 종류와 사용방법

### StaticApplicationContext

`StaticApplicationContext`는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 실무에서는 사용되지 않으며, 권고되지도 않는다. 테스트로 검증할때만 사용해야 한다.

### GenericApplicationContext

일반적인 애플리케이션 컨텍스트의 구현 클래스이다. `StaticApplicationContext`가 내부의 코드를 통해 빈 메타정보를 등록한다면, `GenericApplicationContext`는 외부의 리소스(XML파일 등)를 읽어들여 메타정보로 전환한다.

XML로 만든 빈 설정 메타정보

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/spring-beans-3.0.xsd">
  
  <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
  	<property name="name" value="Spring" />
    <property name="printer" value="printer" />
  </bean>
</beans>
~~~

GenericApplicationContext 테스트

~~~java
@Test
public void genericApplicationContext() {
   GenericApplicationContext ac = new GenericApplicationContext();
   XMLBeanDefinitionReader reader = new XMLBeanDefinitionReader(ac);
   reader.loadBeanDefinitions(
   		"springbook/learningtest/spring/ioc/genericApplicationContext.xml"
   );
   ac.refresh();
  
   Hello hello = ac.getBean("hello", Hello.class);
   hello.print();
  
   assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}
~~~



애플리케이션 개발하면서 `GenericApplicationContext`를 직접 사용할 일은 없다. 독립형 애플리케이션을 개발할 필요가 없기 때문이다. 그러나 독립형 애플리케이션이 필요한 일이 있다. 테스트 환경에서이다. 

JUnit 테스트는 테스트내에서 사용되도록 애플리케이션 컨텍스트를 자동으로 만들어주는데 이 때 만들어주는 애플리케이션 컨텍스트가  `GenericApplicationContext` 이다.

### GenericXmlApplicationContext

`GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 내장하고 있다. 이 때문에 XML 파일을 읽어들이고, `refresh()`를 통해 초기화하는 것까지 한 줄로 할 수 있다.

XML 파일정보는 리소스 로더가 읽을 수 있는 형식으로 `GenericXmlApplicationContext` 생성자에 넣어주면 된다.

### WebApplicationContext

스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트이다. `WebApplicationContext`는 `ApplicationContext`를 확장한 인터페이스이다.

스프링 컨테이너가 DI 작업을 수행해준다고 하지만, 그것만으로 애플리케이션을 작동시킬 수는 없다. `main()`와 같이 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작시켜야 한다.

하나의 빈 오브젝트만 호출하면, 각각의 오브젝트들끼리 DI로 연결되어 있으므로 애플리케이션이 작동될 것이다. 이 때 빈 오브젝트를 호출하는 메소드가 `getBean()`이 사용된다.

그러나 문제는 웹 애플리케이션에서는 `main()`을 호출할 방법이 없다. 그래서 웹에서는 `main()` 대신 서블릿 컨테이너가 브라우저로부터 오는 HTTP 요청을 받아서 해당 요청에 매핑되어 있는 서블릿을 실행해주는 방식으로 웹 애플리케이션을 동작시킨다.

정리하면, `main()` 역할을 하는 서블릿을 만들어두고, 미리 애플리케이션 컨텍스트를 생성해둔 다음, 요청이 서블릿으로 들어올 때마다 `getBean()`으로 필요한 빈을 가져와 정해진 메소드를 실행해주면 된다.

![웹에서 스프링 애플리케이션 기동방식](https://user-images.githubusercontent.com/33862991/123992394-8ae73800-da06-11eb-8994-a64f46d982b1.png)

서블릿 컨테이너는 클라이언트로부터 들어오는 요청을 받아서 서블릿을 동작시키는 역할을 한다. 서블릿은 웹 애플리케이션이 시작될때 미리 만들어둔 `WebApplicationContext`에게 빈 오브젝트로 구성된 애플리케이션의 기동 역할을 해줄 빈을 요청해서 받아둔다. 

### 웹 애플리케이션의 IoC 컨테이너 구성 방법

- 스프링 애플리케이션 요청을 처리하는 서블릿안에서 생성
- 웹 애플리케이션 레벨에서 생성



이에 따라 스프링 웹 애플리케이션은 2개의 WebApplicationContext 오브젝트가 생성된다.

![](resources/애플리케이션컨텍스트구성.jpeg)

두 컨텍스트가 공유해서 사용하는 빈을 담아놓는 별도의 컨텍스트를 만드는데, 이 컨텍스트가 계층구조에서 최상위에 해당하는 루트 애플리케이션 컨텍스트가 된다.

**두 개 이상의 서블릿을 구분해서 애플리케이션 컨텍스트를 계층구조로 만드는 이유**

- 전체 애플리케이션에서 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위함

## IoC 컨테이너 계층구조

모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있으며, 이를 이용하여 트리구조의 컨텍스트 계층을 만들 수 있다.

![IoC 계층구조](https://user-images.githubusercontent.com/33862991/124335938-10214700-dbd7-11eb-920c-0fe12328d4ac.png)

계층구조 안의 모든 컨텍스트는 독립적인 설정정보를 이용하여 빈 오브젝트를 만들고 각자 독립적으로 관리하는 빈이 존재한다.

애플리케이션 컨텍스트가 빈을 찾는 순서는 자기 자신 -> 컨텍스트 - 부모 컨텍스트 순으로 이어진다.

DI를 위해 애플리케이션 컨텍스트가 빈을 찾을 때는 자신이 관리하는 빈에서 찾아보고 없으면 부모 컨텍스트에서 빈을 찾는다. 이 때 형제 관계의 애플리케이션 컨텍스트 또는 자식 관계의 애플리케이션 컨텍스트에서는 찾지 않는다.
위의 이미지에서 A1 에서 빈을 찾는다면, 루트 애플리케이션 컨텍스트에서까지만 찾을뿐 자식관계인 B1, 형제관계인 A2에서는 찾지않는다.   

계층구조의 컨텍스트를 만드는 코드는 아래와 같다.

~~~java
String basePath = StringUtils.classPath(ClassUtils.classPackageAsResourcePAth(getClass()));

// 부모 애플리케이션 컨텍스트 생성
ApplicationContext parent = new GenericXmlApplicationContext(basePath + "parentContext.xml");

// 자식 애플리케이션 컨텍스트 생성
GenericApplicationContext child = new GenericApplicationContext(parent);
~~~

자식 컨텍스트를 생성할때 바라보는 노드로 부모 컨텍스트를 지정한다는 점이 중요하다.

부모 컨텍스트에서의 빈 조회를 제한 할 수도 있고, 반대로 자식 컨텍스트를 건너뛰고 직접 부모 컨텍스트로부터 빈을 조회할 수도 있다.

### 웹 애플리케이션 컨텍스트 구성 방법

- **서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조**
  - 가장 많이 사용되는 구성 방법
  - 웹 관련 빈은 서블릿 컨테이너에 두고,
    나머지는 루트 애플리케이션 컨텍스트에 등록
- **루트 애플리케이션 컨텍스트 단일구조**
  - Spring WebMVC를 사용하지 않는 구성방법
  - 서블릿 애플리케이션 컨텍스트도 필요없음
- **서블릿 컨텍스트 단일구조**
  - 스프링 외의 프레임워크를 사용하지 않거나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아닐 때 사용하는 구성 방법
  - 서블릿 컨텍스트가 부모 컨텍스트를 갖지 않으므로 루트 컨텍스트가 된다.
  - 하지만 모든 컨텍스트에서 공유되는 루트 컨텍스트와는 구별된다. (계층 구조의 차이)

### 루트 애플리케이션 컨텍스트 등록

#### 1. ContextLoaderListener 등록

- 웹 애플리케이션의 시작과 종료시 발생하는 이벤트를 처리하는 리스너인 `ServletContextListener`를 이용
- 인터페이스 `ServletContextListener`를 구현한 리스너는 웹 애플리케이션 전체에 적용 가능한 DB 연결 기능이나 로깅같은 서비스를 만드는데 유용하게 쓰인다.
- 웹 애플리케이션이 시작될때 루트 애플리케이션 컨텍스트를 만들어 초기화하고, 웹 애플리케이션이 종료될 때 컨텍스트를 함께 종료하는 기능을 가진 리스너를 만든다.
- 스프링은 이런 기능을 가진 리스너인 `ContextLoaderListener`를 제공한다.
- `ContextLoaderListener`는 웹 애플리케이션이 시작할 때 자동으로 루트 애플리케이션 컨텍스트를 만들고 초기화해준다.
- 설정파일 위치는 `/WEB-INF/`에 저장한다.
  - `/WEB-INF/applicationContext.xml`

~~~xml
<listener>
   <listener-class>org.springframework.web.context.ContextLoadListener
   </listener-class>
</listener>
~~~

#### 2. 디폴트 XML 설정파일 위치 선언

~~~xml
<context-param>
   <param-name>contextConfigLocation</param-name>
   <param-value>
     	/WEB-INF/daoContext.xml
      /WEB-INF/applicationContext.xml   
   </param-value>
</context-param>
~~~

`contextConfigLocation`의 컨텍스트 파라미터를 넣어주면 디폴트 설정파일 위치인 `/WEB-INF/applicationContext.xml`을 무시하고 파라미터로 제공된 설정파일을 사용한다.

위의 코드처럼 <u>하나 이상의 XML 설정파일 사용할 경우 여러줄에 걸쳐넣거나 공백으로 분리</u>한다.

### 서블릿 애플리케이션 컨텍스트 등록

스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 `DispatcherServlet`이다. web.xml에서 등록해서 사용할 수 있는 서블릿이다.

`DispatcherServlet`은 서블릿이 초기화될 때 자신만의 컨텍스트를 생성하고 초기화한다. 동시에 웹 애플리케이션 레벨에 등록된 루트 애플리케이션 컨텍스트를 찾아서 자신의 부모 컨텍스트로 사용한다.

서블릿 애플리케이션 컨텍스트를 등록하는 방법은 아래와 같다.

~~~xml
<servlet>
   <servlet-name>spring</servlet-name>
   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
   <load-on-startup>1</load-on-startup>
</servlet>
~~~

`DispatcherServlet`을 등록할때 신경써야 할 사항은 두가지다.

#### \<servlet-name>

`DispatcherServlet`으로 만들어지는 애플리케이션 컨텍스트는 모두 독립적인 네임스페이스를 갖는다. 네임스페이스 덕분에 여러 개의 `DispatcherServlet`이 등록되더라도 각각 구분할 수 있고, 자신만의 디폴트 설정파일을 가질 수 있다. 

네임스페이스는 서블릿 단위로 만들어지는 컨텍스트를 구분하는 키가 된다. 

네임스페이스는 `<servlet-name>`으로 지정한 서블릿 이름에 `-servlet`을 붙여서 만든다.

예를들면, `<servlet-name>`이 `spring`이라면, `spring-servlet`이 네임스페이스가 된다. 그럼 디폴트 설정파일의 위치는 `/WEB-INF/spring-servlet.xml`이 된다.

#### \<load-on-startup>

서블릿 컨테이너가 등록된 서블릿을 언제 만들고 초기화할지, 그 순서는 어떻게 되는지를 결정하는 정수 값이다.

<mark>음의 정수</mark>를 넣으면 해당 서블릿은 서블릿 컨테이너가 <mark>임의로 정한 시점</mark>에서 만들어지고, 초기화된다.

<mark>0이상의 양수</mark>를 넣으면 <mark>웹 애플리케이션이 시작되는 시점</mark>에서 서블릿을 로딩하고 초기화한다.

보통 1을 값으로 넣으며, 다른 서블릿과 초기화 우선순위를 조정할 필요가 있을때 값을 변경한다.

<br>

# <a name="1-2"></a>1.2장 IoC/DI를 위한 빈 설정 메타정보 작성

IoC 컨테이너가 하는 역할은 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 것. POJO 클래스와 서비스 오브젝트가 그 대상이며 이렇게 IoC 컨테이너에 의해 관리되는 오브젝트를 빈이라고 한다.

IoC 컨테이너가 빈을 관리하기 위해서는 빈의 메타정보가 필요하다. 이 메타정보를 통해 빈의 클래스와 이름을 제공받는다.

외부 파일이나 애노테이션으로부터 전용 리더를 통해 읽어들여서 BeanDefinition 타입의 오브젝트로 변환한다. 이 BeanDefinition 정보를 IoC 컨테이너가 활용한다.

BeanDefinition은 순수한 오브젝트로 표현되는 빈 생성 정보다. BeanDefinition 생성기를 사용할 수만 있다면 빈 설정 메타정보를 담은 소스는 어떻게 만들어도 상관없다.

## 빈 설정 메타정보

BeanDefinition에는 IoC 컨테이너가 빈을 만들때 필요한 핵심 정보가 담기며, 여러 개의 빈을 만드는데 재사용될 수 있다.

BeanDefinition에는 빈의 이름이나 아이디를 나타내는 정보는 포함되지 않는다. 이 때문에 메타정보는 같지만 이름은 다른 여러개의 빈 오브젝트로 재사용이 가능하다.

## 빈 등록 방법

일반적으로 XML 문서, 애노테이션 등의 외부 리소스로 빈 메타정보를 작성하고 이를 리더를 통해 ApplicationContext가 사용할 수 있는 정보로 변환하는 방법을 사용한다.

빈을 등록하는 5가지 방법이다.

### XML : \<bean> 태그

가장 단순하면서 가장 강력한 빈 설정방법.

`<bean>`을 이용하면 스프링 빈 메타정보의 거의 모든 항목을 지정하는 것이 가능하다.

id와 class 두 개의 애트리뷰트를 사용한다. id는 생략이 가능하다.

~~~xml
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	...
</bean>
~~~

bean은 다른 빈의 \<property> 태그안에 정의될수도 있다. 이때는 id를 지정하지 않는다. 이렇게 다른 빈의 설정 안에서 정의되는 빈을 내부 빈(Inner Bean)이라 한다.

~~~xml
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
   <property>
      <bean class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
   </property>
</bean>
~~~

### XML : 네임스페이스와 전용 태그

스프링은 기술적인 설정과 기반 서비스를 빈으로 등록할때를 위해 의미가 잘 드러나는 네임스페이스와 태그를 가진 설정 방법을 제공한다.

그냥 \<bean> 태그를 사용한 예이다.

~~~xml
<bean id="mypointcut"
      class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
   <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))" />
</bean>
~~~

위의 \<bean>태그로 작성된 포인트컷을 \<aop:pointcut> 태그로 바꿀수 있다.

~~~xml
<aop:pointcut id="mypointcut"
              expression="execution(* *..*SErviceImpl.upgrade*(..))" />
~~~

\<bean>태그로 선언한것과 동일하게 빈 설정 메타정보로 변환하였다. 그러나 네임스페이스(`aop`), 전용 애트리뷰트(`pointcut`)를 이용해 선언했기 때문에 내용이 직관적으로 드러난다.

또 여러개의 \<bean> 태그를 네임스페이스를 이용해서 한줄로 처리할 수도 있다.

~~~xml
<bean id="userController" class="com.mycompany.user.UserController">
	<property name="service" ref="userService" />
</bean>
<bean id="userService" class="com.mycompany.user.UserService">
	<property name="dao" ref="userDao" />
</bean>
<bean id="userDao" class="com.mycompany.user.UserDao">
</bean>
~~~

 위의 \<bean> 태그를 한 줄로 대체하는 예이다.

~~~xml
<aop:module id-prefix="user" class-prefix="User" package="com.mycompany.user" />
~~~

### 자동인식을 이용한 빈 등록 : 스테레오 타입 애노테이션과 빈 스캐너

빈 스캐닝을 통해 특정 애노테이션이 붙은 클래스를 자동으로 찾아서 빈으로 등록해주기도 한다. 이 때 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너라고 한다.

예제 코드이다.

~~~java
@Component
public class AnnotatedHello {
   ...
}
~~~

애노테이션 `@Component`가 붙어있어서 빈 스캐너가 이를 감지하여 자동으로 빈으로 등록해준다. 이 때 클래스이름이 빈의 id가 되며, 위의 예제코드에서는 `annotatedHello`로 등록된다.

만약 빈의 이름을 지정하고 싶다면 애노테이션의 파라미터로 넣어주면 된다.

~~~java
@Component("myAnnotatedHello")
public class AnnotatedHello {
   ...
}
~~~

정말 빈이 등록되었는지 확인하는 테스트 코드이다.

~~~java
@Test
public void simpleBeanScanning() {
   ApplicationContext ctx = new AnnotationConfigApplicationContext(
      "springbook.learningtest.spring.ioc.bean");
  
   AnnotetedHello hello = ctx.getBean("annotatedHello", AnnotatedHello.class);
  
   assertTrue(hello, is(notNullValue()));
}
~~~

### 자바 코드에 의한 빈 등록 : @Configuration 클래스의 @Bean 메소드

스프링은 코드를 이용해서 오브젝트를 생성하고 DI 진행하는 방식으로 만들어진 오브젝트를 빈으로 쓸 수 있는 방법을 제공한다. 

~~~java
@Configuration
public class AnnotatedHelloConfig {
   @Bean
   public AnnotatedHello annotatedHello() {
      return new AnnotatedHello();
   }
}
~~~

XML 문서의 \<beans>를 `@Configuration` 클래스로, \<bean>을 `@Bean` 메소드로 대응한다.

위의 코드를 통해서 메소드뿐 아니라 `@Configuration` 애노테이션이 붙은 클래스 자신도 빈으로 등록이 된다. 이는 `@Component`를 통한 빈 등록과 같다.

**자바 코드에 의한 설정의 장점**

- 컴파일러/IDE를 통한 타입 검증이 가능
- 자동완성 같은 IDE 지원을 이용할 수 있다.
- 이해하기 쉽다.
- 복잡한 빈 설정을 손쉽게 가능

### 자바 코드에 의한 빈 등록 : 일반 빈 클래스의 @Bean 메소드

클래스에 `@Configuration`을 붙이지 않아도 메소드에 `@Bean`을 붙여서 메소드를 빈으로 등록해서 사용할 수 있다.

`@Configuration`이 붙은 클래스에서 `@Bean`이 붙은 메소드는 싱글톤이기 때문에 여러번 호출돼도 하나의 오브젝트만 리턴되는 것이 보장된다. 하지만 일반 클래스에 `@Bean` 을 사용한 경우는 DI 설정을 위해 Bean 메소드를 호출할때마다 매번 다른 오브젝트를 받게 된다.

~~~java
public class HelloService {
   @Bean
   public Hello hello() {
      Hello hello = new Hello();
      hello.setPrinter(printer());
      return hello;
   }
}
~~~

따라서 일반 빈 클래스에서 `@Bean` 애노테이션을 사용하면서 DI를 위해 다른 메소드를 호출할때는 해당 메소드를 생성자로 주입받아서 싱글톤 오브젝트로 생성해두고 이를 가져다 사용하는 방식으로 해결해야한다.

~~~java
public class HelloService {
   private Printer printer;
  
   public void setPrinter(Printer printer) {
      this.printer = printer;
   }
  
   @Bean
   public Hello hello() {
      Hello hello = new Hello();
      hello.setPrinter(this.printer);
      return hello;
   }
}
~~~

<br>

## 빈 등록 메타정보 구성 전략

- **XML 단독 사용**
  - 모든 설정 정보를 자바 코드에서 분리하고 순수한 POJO 코드를 유지할 수 있는 방법
- **XML과 빈 스캐닝의 혼용**
  - 빈 클래스는 복잡한 메타 정보를 필요로 하지 않는다. 대부분 싱글톤이며, 클래스당 하나만 만들어지므로 빈 스캐닝에 의한 자동인식 대상으로 적절하다.
  - 자동인식 방식으로 등록하는 불편한 기술 서비스, 기반 서비스, 컨테이너 설정 등의 빈은 XML을 사용하면 된다.
  - <span style="color: red">스캔 대상이 되는 클래스를 위치시킬 패키지를 미리 결정</span>해야한다는 점을 주의해야한다.
    - 웹 기반의 스프링 애플리케이션은 보통 <mark>2개의 애플리케이션 컨텍스트가 등록</mark>되서 사용된다.
    - 빈 스캐닝은 한 번에 최상위 패키지를 지정해서 스캐닝을 하는데 이때 <mark>양쪽 컨텍스트의 빈 스캐너가 같은 클래스를 중복으로 빈으로 등록할 가능성</mark>이 존재한다.
- **XML 없이 빈 스캐닝 단독 사용**
  - XML없이 빈 스캐닝의 자동스캔만으로 가능하다.
  - 모든 빈의 정보가 자바 코드에 담겨있으므로 빈의 설정정보를 타입에 안전한 방식으로 작성할 수 있다.
  - XML을 사용하지 않기 때문에 포기해야하는 부분도 존재한다. 가장 큰 단점은 스프링이 제공하는 스키마에 정의된 전용 태그를 사용할 수 없다는 것이다.

<br>

## 빈 의존관계 설정 방법

빈 오브젝트 사이의 DI를 위한 의존관계 메타정보를 작성하는 방법이다.

DI할 대상을 선정하는 방법은 크게 두가지로 정리된다.

- 빈의 아이디(DI 대상 빈)를 직접 지정
- 타입 비교를 통해서 호환되는 타입의 빈을 DI 후보로 선정
  - 이 방법을 자동 와이어링(Autowiring)이라고 한다.

---

### XML - \<property> : 수정자 주입, \<constructor-arg> : 생성자 주입

`<bean>`을 이용하여 빈을 등록했다면 프로퍼티와 생성자 두 가지 방식으로 DI를 지정할 수 있다. 두가지 방법 모두 의존 오브젝트 또는 값을 주입한다.

- 프로퍼티는 자바빈 규약을 따르는 수정자 메서드를 사용하는 방법
- 생성자는 빈 클래스의 생성자를 이용하는 방법

#### XML \<property> : 수정자 주입

`<property>` 태그를 사용하며 `ref` 애트리뷰트에 빈 이름을 입력하면 해당 빈을 찾는다.

~~~xml
<bean id="printer">
   <property name="printer" ref="defaultPrinter" />
</bean>
<bean id="defaultPrinter" class="...">
~~~

`value` 애트리뷰트는 단순 값 또는 빈이 아닌 오브젝트를 주입할때 사용한다.

~~~xml
<property name="name" value="Spring"/>
<property name="age" value="30"/>
<property name="myClass" value="java.lang.String"/>
~~~

`value` 애트리뷰트의 값으로는 모든 타입이 가능한데, XML로 작성되기 때문에 일단 문자열로 작성해야 한다. 위의 프로퍼티에서 `value`의 타입은 각각 문자열(String), 정수형(int), Class 타입이다.

XML만 봐서는 주입되는 값의 타입이 호환되는지 알 수 없으므로 이를 주의해야한다.

#### XML \<constructor-arg> : 생성자 주입

빈으로 사용할 클래스의 생성자가 아래와 같다고 가정한다.

~~~java
public class Hello {
   private String name;
   private Printer printer;
   
   public Hello(String name, Printer printer) {
      this.name = name;
      this.printer = printer;
   }
}
~~~

생성자의 파라미터가 2개이다. 따라서 XML에서 주입할 정보도 2가지여야 한다.

~~~xml
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
   <constructor-arg index="0" value="Spring" />
   <constructor-arg index="1" value="printer" />
</bean>
~~~

위의 XML은 index 지정 방법이다.

파라미터에 <span style="color:red;"><u>중복되는 타입이 없다면</u></span> 타입 지정방식으로도 가능하다.

~~~xml
<constructor-arg type="java.lang.String" value="Spring" />
<constructor-arg type="springbook.learningtest.spring.ioc.bean.Printer" ref="printer"/>
~~~

생성자 주입시엔 파라미터 순서가 뒤바뀌지 않도록 주의해야한다.

### XML : 자동와이어링

XML 문서의 양을 대폭 줄여줄수 있는 방법이다. 하지만 그만큼 위험도도 있다.

명시적으로 프로퍼티나 생성자 파라미터를 지정하지 않고 미리 정해진 규칙을 이용하여 자동으로 DI 설정을 컨테이너가 추가하도록 하는 방법이다. 그러나 이 규칙을 엄격하게 지켜야 한다는 부담이 따르기도 한다.

자동와이어링이 필요한 경우는, 규모가 큰 프로젝트에서 모든 개발자가 규칙에 따라 정확하게 이름을 부여하기 어려울때 이름 대신 타입에 의한 자동 와이어링을 사용하면 이점이 될 수 있다.

자동으로 관계가 맺어져야할 빈을 찾아서 연결한다는 의미로 자동와이어링이라 한다.

자동와이어링은 두가지가 존재한다.

- **byName** : 빈 이름 자동와이어링
- **byType** : 빈 타입 자동와이어링

### XML : 네임스페이스와 전용 태그

전용 태그를 참조하는 빈

~~~xml
<bean id="sqlService" class="springbook.user.sqlservice.OxmSqlService">
   <property name="unmarshaller" ref="unmarshaller" />
   <property name="sqlRegistry" ref="sqlRegistry" />
</bean>
~~~

전용 태그에서 다른 빈을 참조하는 경우

~~~xml
<aop:config>
   <aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" />
</aop:config>
<bean id="transactionAdvice" ...></bean>
~~~

빈의 아이디와 레퍼런스를 명시적으로 선언하는 방식으로 사용하면 네임스페이스를 쓰는 전용 태그도 간단히 의존관계를 정의할 수 있다. 

 가능하면 <mark>XML에서 파악이 불가한 자동와이어링보다는 id와 레퍼런스를 명시적으로 선언하는 방식이 바람직하다.</mark>

### 애노테이션: @Resource

- 수정자
- 필드

### 애노테이션: @Autowired/@Inject



### @Autowired와 getBean(), 스프링 테스트



### 자바 코드에 의한 의존관계 설정



### 빈 의존관계 설정 전략



<br>

# <a name="1-3"></a>1.3 프로토타입과 스코프

스프링의 빈은 싱글톤으로 생성된다. 요청이 있을 때마다 애플리케이션 로직을 담은 오브젝트를 새로 담는건 비효율적이기 때문이다.

그러나 하나의 빈 설정으로 여러 오브젝트를 만들어서 사용할때는 싱글톤이 아닌 다른 방법으로 빈을 만들어 사용해야한다.

싱글톤 빈이 아닌 빈은 크게 <mark>프로토타입 빈</mark>과 <mark>스코프 빈</mark>으로 구성된다.

> 빈 스코프란, 빈 오브젝트가 만들어져 존재할 수 있는 범위를 의미한다. 빈 오브젝트의 생명주기는 스프링 컨테이너가 관리하므로 스코프의 끝까지 빈 오브젝트가 존재하게 된다.

> 싱글톤 스코프는 컨테이너의 스코프와 싱글톤의 스코프가 일치하기 때문에 컨테이너 스코프라고도 한다.

## 1.3.1 프로토타입 스코프

싱글톤 빈은 DI이든 DL(Dependency Lookup, 의존객체 조회)이든 상관없이 매번 같은 오브젝트가 사용된다는 사실을 테스트를 통해 확인하자.

~~~java
@Test
public void singletonScope() {
   ApplicationContext ac = new AnnotationConfigApplicationContext(
      SingletonBean.class, SingletonClientBean.class);  // 싱글톤 빈으로 생성
   Set<SingletonBean> beans = new HashSet<SingletonBean>();  // 중복을 허용하지 않는 Set을 사용
  
   beans.add(ac.getBean(SingletonBean.class));      //
   beans.add(ac.getBean(SingletonBean.class));      // DL에서 싱글톤 확인
   assertEquals(beans.size(), 1);                   //
  
   beans.add(ac.getBean(SingletonClientBean.class).bean1);  //
   beans.add(ac.getBean(SingletonClientBean.class).bean2);  // DI에서 싱글톤 확인
   assertEquals(beans.size(), 1);                           //
}
static class SingletonBean { }
static class SingletonClientBean {  // 한 번 이상의 DI가 발생하도록 두개의 DI용 프로퍼티 선언
   @Autowired SingletonBean bean1;
   @Autowired SingletonBean bean2;
}
~~~

![테스트 결과](resources/vol2_1_3_test_1.png)

테스트를 실행해보면 DI에서든 DL에서든 Set에 빈을 추가했음에도 Set의 `size()`가 1에 머무러있는걸 알 수 있다. 

항상 동일한 오브젝트가 돌아왔기 때문이며, 빈 오브젝트가 싱글톤이기 때문이다.

프로토타입 스코프로 빈을 선언해서 다시 테스트한다.

~~~java
@Test
public void prototypeScope() {
   ApplicationContext ac = new AnnotationConfigApplicationContext(
      PrototypeBean.class, PrototypeClientBean.class);  // 프로토타입 스코프로 빈 생성
   Set<PrototypeBean> bean = new HashSet<PrototypeBean>();
  
   beans.add(ac.getBean(PrototypeBean.class));   //    
   assertEquals(beans.size(), 1);                // 프로토타입 빈은 DL 방식으로 
   bean.add(ac.getBean(PrototypeBean.class));    // 컨테이너에 빈을 요청할 때마다
   assertEquals(beans.size(), 2);                // 빈 오브젝트가 만들어지는걸 확인 
  
   bean.add(ac.getBean(PrototypeClientBean.class).bean1);
   assertEquals(beans.size(), 3);
   bean.add(ac.getBean(PrototypeClientBean.class).bean2);
   assertEquals(beans.size(), 4);
}

@Scope("prototype")   // 애노테이션 이용해 프로토타입 빈으로 만들려면 @Scope의 기본 값을 prototype으로 지정
static class PrototypeBean { }
static class PrototypeClientBean {
   @Autowired PrototypeBean bean1;
   @Autowired PrototypeBean bean2;
}
~~~

![테스트 결과](resources/vol2_1_3_test_2.png)

프로토타입 빈으로 생성하니 매번 새로운 오브젝트가 만들어져서 빈을 Set에 추가할 때마다 Set의 `size()`가 1씩 늘어난걸 알 수 있다.

#### 프로토타입 빈 생명주기와 종속성

스프링이 관리하는 빈은 모든 생명주기를 스프링 컨테이너에서 관리한다. 그러나 프로토타입 빈은 다르다.

프로토타입 스코프를 갖는 빈은 요청이 있을때마다 컨테이너가 생성하고  초기화하고 DI까지 해주지만, 빈을 제공한 이후부터는 컨테이너가 더 이상은 빈을 관리하지 않는다.

프로토타입 빈은 컨테이너가 초기 생성 시에만 관여하고, DI 한 후에는 더이상 신경쓰지 않기 때문에, DI 이후부터는 DI받은 오브젝트에게 프로토타입 빈의 관리가 넘겨진다. 따라서 프로토타입 빈의 생명주기는 DI 받은 오브젝트의 생명주기를 따른다.

#### 프로토타입 빈의 용도

- `new`로 오브젝트를 생성하는 것을 대신하기 위해 사용
-  매번 새로운 오브젝트가 필요하며 DI를 통해 다른 빈을 사용할 수 있는 상황에 프로토타입 빈이 좋은 선택이 된다.

#### 프로토타입 빈의 DL 전략

- ApplicationContext, BeanFactory
  - ApplicationContext 또는  BeanFactory를 DI 받은 뒤에  `getBean()`을 호출해서 빈을 가져오는 방법이다.
- ObjectFactory, ObjectFactoryCreatingFactoryBean
  - 직접 ApplicationContext를 사용하지 않으려면 중간에 `getBean()`을 호출할 오브젝트가 필요 -> 팩토리 필요
  - 팩토리를 DI 받아서 필요할때 `getObject()`같은 메서드 호출
  - 스프링이 제공하는 `ObjectFactory` 인터페이스 사용
  - `ObjectFactory`는 DL을 이용해 빈을 가져와야하는 모든 경우에 적용 가능
- ServiceLocatorFactoryBean
  - 스프링이 제공하는 인터페이스 대신 직접 정의한 팩토리 인터페이스를 `ObjectFactory`처럼 이용가능.
- 메서드 주입
  - 메소드를 통해 DI받는게 아니라 메소드 코드 자체를 주입하는 것
  - ApplicationContext와 getBean() 메소드를 사용해 새로운 프로토타입 빈을 가져오는 기능을 담당하는 메소드를 런타임시에 추가하는 기술.
- Provider\<T>
  - `@Inject`와 함께 JSR-330에 추가된 표준 인터페이스이다.
  - ObjectFactory와 유사하지만 `ObjectFactoryCreatingFactoryBean`을 이용해 빈을 등록해주지 않아도 되기때문에 더 편하다는 이점이 있다.

<br>

## 1.3.2 스코프

#### 스코프의 종류

스프링이 제공하는 스코프는 아래 4가지를 제공한다.

- 요청 (request)
- 세션 (session)
- 글로벌세션 (global session)
- 애플리케이션 (application)

#### 요청 스코프

- 하나의 웹 요청안에서 생성되고 요청이 끝나면 제거된다.

- 각 요청별로 독립적인 빈이 생성되기 떄문에 빈 오브젝트에 상태값을 저장해도 된다.

- 하나의 웹 요청을 처리하는 동안 참조하는 요청 스코프빈은 항상 동일한 오브젝트임이 보장되지만, 동시에 웹 요청이 달라지면 별도의 요청 스코프 빈이 생성되기 때문에 동시에 여러 요청을 보내도 안전하다.

#### 세션 스코프 / 글로벌세션

- HTTP 세션과 같은 존재 범위를 갖는 빈으로 만들어주는 스코프다.

- 세션 스코프를 이용 하면 HTTP 세션에 저장되는 정보를 모든 계층에서 안전하게 이용이 가능하다.

- 글로벌세션 스코프는 포틀릿에만 존재하는 글로벌 세션에 저장되는 빈이다.

#### 애플리케이션 스코프

- 서블릿 컨텍스트에 저장되는 빈 오브젝트이다.
- 컨텍스트가 존재하는 동안 유지되는 싱글톤 스코프와 비슷한 스코프를 갖는다.
- 싱글톤 스코프와 마찬가지로 상태를 갖지 않거나 상태가 있더라도 읽기전용으로 만들거나, 멀티쓰레드 환경에서 안전하도록 만들어야 한다.

#### 스코프 빈의 사용 방법

- 하나 이상의 오브젝트가 만들어져야 하기 때문에 싱글톤에 DI 해주는 방법으론 사용불가능하다.
- <mark>스코프 빈은 프로토타입 빈과 마찬가지로 DL 방식으로 사용해야 하나 DI를 사용하기 위해 스코프 빈에 대한 프록시를 생성해서 DI 한다.</mark>
- 클라이언트에서 스코프 프록시 오브젝트를 실제 스코프 빈처럼 사용하면 <mark>프록시에서 현재 스코프에 맞는 빈 오브젝트로 작업을 위임한다.</mark>
- 스코프 프록시는 각 요청에 연결된 세션 정보를 참고해서 사용자마다 다른 오브젝트를 사용하게 해준다.
- 스코프 프록시는 실제 스코프 오브젝트를 상속한다.
- 프록시 방식의  DI를 적용하면 스코프 빈이지만 싱글톤 빈을 사용하듯 편하게 쓸수 있다는 장점이 있다. 그러나 주입되는 빈의 스코프를 모르면 코드를 이해하는 것이 어려울수도 있다.

#### 커스텀 스코프와 상태를 저장하는 빈 사용하기

- 스프링이 기본으로 제공하는 스코프외에 임의의 스코프를 만들어 사용할 수 있다.
- 싱글톤외에 스코프를 사용한다는건 기본적으로 빈에 상태를 저장해두고 사용한다는 의미이다.
- 스프링에서 Scope 인터페이스를 구현해서 새로운 스코프를 작성할 수 있다.
- 빈에 상태를 저장해두는 방식을 선호하지 않는다면, 상태정보를  URL, 파라미터, 쿠키, 폼 히든 필드, DB, HTTP 세션등에 분산해 저장해두고 코드로 관리하면 된다.

<br>

# <a name="1-4"></a>1.4 기타 빈 설정 메타정보

## 1.4.1 빈 이름

빈은 하나이상의 식별자를 가질 수 있으며, 빈의 식별자는 빈이 정의된 애플리케이션 컨텍스트 내에서 고유하다.

빈의 식별자는 XML이라면,  `<bean>` 태그의 `id`, `name` 애트리뷰트를 이용해 정의 가능하다.

#### id

XML의 ID 타입의 기준을 지켜야 한다.

-  공백이 들어갈 수 없다.
- 첫글자는 알파벳과 밑줄(_), 그리고 허용된 일부 언어문자만 사용가능하다.
- 나머지 글자는 알파벳과 밑줄(_), 숫자와 점(.)을 이용한다. 그외 특수문자는 사용 불가능하다.

위의 기준을 지켜서 정의한 빈 id의 예이다.

~~~xml
<bean id="_hello.Service123" class="..." />
~~~

id에 사용하는 값은 빈을 대표하는 타입 이름을 첫글자만 소문자로 바꿔서 사용한다.

`UserService` 타입의 빈이라면, 다음과 같이 id를 만든다.

~~~xml
<bean id="userService" class="..." />
~~~

#### name

id와 달리 name은 제약이 없다. 또한 여러개의 하나의 빈에 여러개 name을 등록할 수 있다. 여러개의 name을 등록할 때는 `,또는 `;`으로 구분한다.

~~~xml
<bean name="123,/hello;헬로우" class="..." />
~~~

위의 빈은 `123`, `/hello`, `헬로우`로 이름이 등록된 빈이다.

name을 복수로 등록 가능한 이유는 이전에 만들었던 빈과 그 설정을 그대로 가져와서 사용하는 일이 발생하기 때문이다. 새로 구성한 빈들과 이름을 그 때마다 새로 짓기대신 기존에 존재하는 빈에 이름을 추가하는 방식이 편리하기 때문이다.

#### 애노테이션에서 빈 이름

빈 스캐너가 자동으로 인식하도록 한 경우에는 보통 클래스 이름을 빈 이름으로 그대로 사용한다. 첫 글자만 소문자로 바꿔서 사용한다.

~~~java
@Component
public class UserService { ... }
~~~

이렇게 할경우 빈 이름은 `userService`가 된다.

메서드도 마찬가지다.

~~~java
@Configuration
public class Config {
   @Bean
   public UserDao userDao() { ... }
}
~~~

빈 이름은 `userDao`가 된다.

자동으로 빈 이름을 사용하는 것이 더 선호되나 임의로 빈 이름을 등록하는 방법도 있다.

~~~java
@Component("myUserService")
public class UserService { ... }
~~~

또는

~~~java
@Component
@Named("myUserService")
public class UserService { ... }
~~~

메서드를 빈으로 등록할 때 임의의 빈 이름을 지정하는 방식은 아래와 같다.

~~~java
@Configuration
public class Config {
   @Bean(name="myUserDao")
   public UserDao userDao() { ... }
}
~~~

`@Bean`을 이용할 경우에는 빈 이름을 여러개 지정할 수 있다.

~~~java
@Configuration
public class Config {
   @Bean(name={"myUserDao", "userDao"})
   public UserDao userDao() { ... }
}
~~~

<br>

## 1.4.2. 빈 생명주기 메소드

### 초기화 메서드 ( Initialization Method )

빈 오브젝트가 생성되고  DI 작업까지 마친 다음에 실행되는 메서드이다.

초기화 메서드를 지정하는 방법은 4가지이다.

- 초기화 콜백 인터페이스
- init-method 지정
- @PostConstruct
- @Bean(init-method)

#### 초기화 콜백 인터페이스

InitializingBean 인터페이스를 구현해서 빈을 작성하는 방법이다.

`afterPropertiesSet()`는 프로퍼티 설정까지 마친 뒤에 호출되는데, 이 때 스프링 인터페이스를 노출하기 때문에 권장하는 방식이 아니다. 

#### init-method 지정

XML을 이용해 빈을 등록한다면 `<bean>` 태그에 init-method 애트리뷰트를 넣어서 초기화 작업을 수행할 메서드 이름을 지정할 수 있다.

~~~xml
<bean id="myBean" class="MyBean" init-method="initResource" />
~~~

DI 를 마친 뒤에 `initResource()`가 실행되도록 선언한 빈이다.

초기화 콜백 인터페이스와 달리 빈 클래스에 스프링 API가 노출되지 않는다는 장점이 있다.

그러나 XML 설정에서 init-method를 빼먹을 위험도 존재한다.

#### @PostConstruct

초기화를 담당할 메소드에 `@PostConstruct` 애노테이션을 부여해주기만 하면 되는 방식이다.

표준인터페이스이기도 하고, XML의 init-method 설정보다 직관적이기 때문에 가장 권장되는 방식이다. 

#### @Bean(init-method)

`@Bean` 메서드를 이용해서 빈을 정의하는 경우에는 `@Bean` 애노테이션의 nit-method 엘리먼트를 사용해서 초기화 메서드를 지정할 수 있다.

~~~java
@Bean(init-mehtod="initResource")
public void MyBean myBean() { ... }
~~~

### 제거 메서드

제거 메서드는 컨테이너가 종료될떄 호출해서 빈이 사용한 리소스를 반환하거나 종료 전에 처리해야 할 작업을 수행한다.

- 제거 콜백 인터페이스
  - `DisposableBean` 인터페이스를 구현해서 `destroy()`를 구현한다.
  - 스프링 API에 종속되는 코드를 만드는 단점이 있다.
- destroy-method
  - `<bean>` 태그에destory-method를 넣어 제거 메서드를 지정 가능ㅎ하다.
- @PreDestory
  - 컨테이너가 종료될때 실행될 메서드에 `@PreDestroy` 를 붙여주면 된다.
- @Bean(destroyMethod)
  - `@Bean` 애노테이션션의 destroyMethod 엘리먼트를 이용해서 제거 메서드를 지정할 수 있다.

<br>

## 1.4.3 팩토리 빈과 팩토리 메소드

- FactoryBean 인터페이스

  - FactoryBean 인터페이스를 구현해서 다이내믹 프록시를 생성하는 getObject() 메서드를 구현하고 팩토리 빈으로 등록해서 사용한다.

- 스태틱 팩토리 메서드

  - 클래스의 스태틱 메서드를 호출해서 인스턴스를 생성하는 방식이다.
  - factory-method 애트리뷰트를 이용하면 빈 오브젝트를 만들 수 있다.

- 인스턴스 팩토리 메서드

  - 오브젝트의 인스턴스 메서드를 이용해 빈 오브젝트를 생성할 수 있다.
  - 하지만 `FactoryBean`이라는 스프링 인터페이스에 종속적이라는 단점이 존재한다.
  - 임의의 오브젝트의 메서드를 호출해서 빈을 생성해야 한다면 factory-bean과 factory-method를 함께 사용할 수 있다.

  ~~~xml
  <bean id="logFactory" class="...LogFactory" />
  <bean id="log" factory-bean="logFactory" factory-method="craeteLog" />
  ~~~

- @Bean 메서드

  - 자바 코드로 등록하는 `@Bean` 메서드를 사용하는 방식도 팩토리 메서드 방식이다.
  - 스프링 컨테이너가 `@Bean` 메서드를 실행해 빈 오브젝트를 가져오는 방식이기 때문이다.
  - 특정 빈만 팩토리 메서드를 통해 만들고 싶다면 빈 클래스에 `@Bean`를 추가하는 방법을 사용하는 것이 좋다. 

<br>

# <a name="1-5"></a>1.5장 스프링 3.1의 IoC 컨테이너와 DI

- **빈의 역할과 구분**

  - 빈의 종류

    - 애플리케이션 로직 빈

      ~~~
      - 스프링에서 말하는 빈은 IoC 컨테이너에 의해 생성되고 관리되는 오브젝트.
      - 애플리케이션의 로직을 담는 주요 클래스의 오브젝트가 빈으로 지정된다.
      - 데이터 로직을 다루는 DAO, 비즈니스 로직과 기반 서비스를 다루는 서비스 오브젝트 등이 여기에 속한다.
      ~~~

    - 애플리케이션 인프라 빈

      ~~~
      - 애플리케이션 로직 빈을 지원하는 빈이 여기에 속한다.
      - 예를 들면 DB와의 연결을 담당하는 DataSource 오브젝트는 여러 DAO와 관계를 맺으며 DB 커넥션에 대한 트랜잭션을 관리하는 책임을 진다. 마찬가지로 빈으로 등록돼서 IoC 컨테이너에 의해 만들어지고 다른 빈과 관계를 맺고 동작을 하게된다.
      - 그러나 DataSource는 DAO와는 성격이 다른데, 애플리케이션 로직을 담지않는다. 
      - 애플리케이션 로직 빈의 일종이지만 개발자가 직접 작성하는 로직이 아니기 때문에 인프라 빈으로 분류된다.
      ~~~

    - 컨테이너 인프라 빈

      ~~~
      - 스프링 컨테이너의 기능을 확장하는 빈이다.
      - <bean> 태그를 이용하지 않고 전용태그를 이용한다.
      ~~~

  - 빈의 역할

    BeanDefinitionUtils.printBeanDefinitions()를 출력하면 콘솔의 좌측에서 볼수 있는 숫자 값이 있다. BeanDefinition 인터페이스에 정의되어 있는 ROLE_로 시작하는 상수인데 빈의 메타정보 오브젝트의 role 프로퍼티 값을 지정할 때 사용한다.

    ~~~java
    int ROLE_APPLICATION = 0;
    int ROLE_SUPPORT = 1;
    int ROLE_INFRASTRUCTURE = 2;
    ~~~

    스프링의 빈은 아래 세가지 역할로 구분된다.

    - ROLE_APPLICAITON

      ~~~
      애플리케이션 로직 빈과 인프라 빈처럼 애프리케이션이 동작하는중에 사용되는 빈
      ~~~

    - ROLE_SUPPORT

      ~~~
      복합 구조의 빈을 정의할때 보조적으로 사용되는 빈의 역할
      ~~~

    - ROLE_INFRASTRUCTURE

      ~~~
      전용 태그에 의해 등록되는 컨테이너 인프라 빈들이 이 값을 갖는다.
      ~~~

- **컨테이너 인프라 빈을 위한 자바 코드 메타정보**

  | 버전       | 애플리케이션 로직빈         | 애플리케이션 인프라 빈 | 컨테이너 인프라 빈   |
  | ---------- | --------------------------- | ---------------------- | -------------------- |
  | 스프링 1.x | \<bean>                     | \<bean>                | \<bean>              |
  | 스프링 2.0 | \<bean>                     | \<bean>                | 전용태그             |
  | 스프링 2.5 | \<bean>, 빈 스캔            | \<bean>                | 전용 태그            |
  | 스프링 3.0 | \<bean>, 빈 스캔, 자바 코드 | \<bean>, 자바 코드     | 전용 태그            |
  | 스프링 3.1 | \<bean>, 빈 스캔, 자바 코드 | \<bean>, 자바 코드     | 전용 태그, 자바 코드 |

  - 자바 코드를 이용한 컨테이너 인프라 빈 등록

    XML에서 전용 태그로 정의하는 부분을 자바 코드로 구현하는 방법이다. 전용 애노테이션과 자바 코드를 사용한다.

    - @ComponentScan

      - 패키지 경로를 입력한 패키지 하위 클래스 중에서 탐색

        ~~~java
        @Configuration
        @ComponentScan("springbook.learningtest.spring31.ioc.scanner")
        public class AppConfig { }
        ~~~

      - 마커 클래스 이용

        ~~~java
        @Configuration
        @ComponentScan(basePackageClasses=ServiceMarker.class)
        public class AppConfig { }
        ~~~

      - 특정 애노테이션 제외

        ~~~java
        @Configuration
        @ComponentScan(basePackageClasses="myproject",
                       excludeFileter=@Filter(Configuration.class))
        public class AppConfig { }
        ~~~

      - 특정 클래스를 제외

        ~~~java
        @Configuration
        @ComponentScan(basePackages="myproject",
                      excludeFilters=@Filter(type=FilterType.ASSIGNABLE_TYPE,
                      value=AppConfig.class))
        public class AppConfig { }
        ~~~

    - @Import

      - 다른 @Configuration 클래스를 빈 메타정보에 추가할 때 사용한다.
        - 역할에 따라 @Configuration 클래스를 분리하는 경우가 있음.
        - 이때 @Import를 사용하면 @Configuration 클래스를 상속하는것과 유사한 일을 기대할 수 있음.

      ~~~java
      @Configuration
      @Import(DataConfig.class)
      public class AppConfig { }
      
      @Configuration
      public class DataConfig { }
      ~~~

    - @ImportResource

      - XML이 반드시 필요한 빈 설정만 별도의 파일로 작성한 뒤에 @Configuration 클래스에서 @ImportResource를 이용하여 XML 파일의 빈 설정을 가져올 수 있다.
      - 예를 들면, 스프링 시큐리티의 보안 관련 전용 태그를 사용해야 해서 XML 빈 설정을 사용해야 한다면 다음과 같이 작성할 수 있다.

      ~~~java
      @Configuration
      @ImportResource("/myproject/config/security.xml")
      public class AppConfig { }
      ~~~

    - @EnableTransactionManagement

      ~~~
      XML의 <tx:annotation-drive/> 태그와 동일한 기능을 수행한다.
      ~~~

- **웹 애플리케이션의 새로운 IoC 컨테이너 구성**

  스프링 3.1에서는 XML을 배제하고 자바 코드 설정 메타정보만을 사용하거나 자바 코드 설정을 주로 하고, XML을 보조적으로 사용할 수 있다.

  - 루트 애플리케이션 컨텍스트 등록

    - @Configuration이 붙은 AppConfig 클래스를 빈 설정 메타정보로 해서 
          루트 애플리케이션 컨텍스트가 생성되도록 하는 예제
          contextClass와 contextConfigLocation 파라미터가 필요하다.

    ~~~xml
    <context-param>
       <param-name>contextClass</param-name>
       <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </context-param>
    
    <context-param>
       <param-name>contextConfigLocation</param-name>
       <param-value>myproject.config.AppConfig</param-value>
    </context-param>
    ~~~

  - 서블릿 컨텍스트 등록

    - 서블릿 컨텍스트는 DispatcherServlet 서블릿을 등록해서 사용.
    - 루트 애플리케이션 컨텍스트와 마찬가지로 XmlWebApplicationContext가 디폴트 컨텍스트 클래스이다.

- **런타임 환경 추상화와 프로파일**

  - 환경에 따른 빈 설정 정보 변경 전략과 한계

    - 빈 설정파일의 변경
      - 빈 설정파일(XML/@Configuration)을 필요할때마다 변경하는 일은 매우 번거롭고 위험하다. 
    - 프로퍼티 파일 활용
      - 환경에 따라 달라지는 정보만을 담은 프로퍼티 파일(.properties)을 만들어서 환경에따라 이 부분만 변경한다.
      - 운영환경에서 테스트 DB를 사용하는 일 등을 주의할 필요가 있다.
      - 그러나 빈 메타정보 자체가 바뀌는 경우에는 환경에 따라 설정이 바뀌는 문제를 간단히 해결하는 것이 불가능

  - 런타임 환경과 프로파일

    - 런타임 환경 = 프로파일 + 프로퍼티 소스
    - 환경에 따라 프로파일과 프로퍼티 소스가 다르게 설정된 Environment 오브젝트가 사용되는 식이다.

  - 활성 프로파일 지정 방법

    - 특정 프로파일에 정의된 빈을 사용하고 싶을때 해당 프로파일을 활성active 프로파일로 만든다.

      ~~~java
      GenericXmlApplicationContext ac = new GenericXmlApplicationContext();
      ac.getEnvironment().setActivePRofiles("dev");
      ac.load(getClass(), "applicationContext.xml");
      ac.refresh();
      ~~~

    - JVM의 커맨드라인 파라미터를 이용하여 시스템 프로퍼티를 지정할 수도 있다.

      ~~~
      -Dspring.profiles.active=dev
      ~~~

    - 서블릿 컨텍스트 파라미터로 활성 프로파일을 지정하면 루트 애플리케이션 컨텍스트와 서블릿 컨텍스트에 모두 적용된다.

      ~~~xml
      <context-param>
         <param-name>spring.profiles.active</param-name>
         <param-value>dev</param-value>
      </context-param>
      ~~~
    
  - 프로파일 활용 전략

    - 애플리케이션에 적용된 활성 프로파일 확인 방법

      ~~~
      컨텍스트 오브젝트의 getEnvironment()로 런타임 환경 오브젝트를 가져와서 getActiveProfiles()를 실행하면, 활성 프로파일 목록을 가져올 수 있다.
      ~~~

    - @Configuration 클래스를 이용하여 빈을 정의할때에도 프로파일 지정 가능

      - 이때에 프로파일 지정단위는 @Configuration

      ~~~java
      @Configuration
      @Profile("dev")
      public class DevConfig { }
      ~~~

- **프로퍼티 소스**

  - 자바에서 말하는 프로퍼티는 기본적으로 키와 그에 대응되는 값의 쌍을 말한다.

  - 프로퍼티 파일은 텍스트 파일 포맷으로 되어 있으며, 여기에 `'키=값'` 형태로 프로퍼티를 기술한다.

  - 프로퍼티의 종류

    - 환경변수

      - 스프링 애플리케이션이 구동되는 OS의 환경변수도 키와 값으로 표현되는 대표적인 프로퍼티.
      - 환경변수 프로퍼티는 같은 시스템에서 여러 개의 WAS를 구동하더라도 모두 동일하게 적용되는, 매우 넓은 범위에 적용되는 프로퍼티다.
      
    - 시스템 프로퍼티

      - JVM 레벨에 정의된 프로퍼티를 말한다.
      - 시스템 관련 정보(os, name, user, home 등)부터 자바 관련정보(java home, java version, java.class.path 등) 등이 시스템 프로퍼티로 등록된다.
      - -D로 지정한 커맨드라인 옵션도 여기에 포함된다.
      
    - JNDI
    
      - Java Naming and Directory Interface
      - 자바 애플리케이션을 외부 디렉토리 서비스에 연결하는 API이다.
      - WAS에 여러 개의 웹 애플리케이션이 올라가고 그 중 하나의 애플리케이션에만 프로퍼티를 지정할때 JNDI 프로퍼티 또는 JNDI 환경 값을 사용할만하다.
      - 더 읽어보기 : [이승현 - 초보자를 위한 JNDI](https://hamait.tistory.com/331)
    
    - 서블릿 컨텍스트 파라미터
    
      ~~~
      서버에서 웹 애플리케이션 범위의 JNDI 값을 설정하기가 번거롭다면 web.xml에 서블릿 컨텍스트 초기 파라미터를 프로퍼티로 사용할 수 있다.
      <context-param>을 사용한다.
      ~~~
    
    - 서블릿 컨피그 파라미터
    
      ~~~
      서블릿 컨피그는 서블릿 컨텍스트와 구분된다.
      서블릿 컨피그는 개별 서블릿을 위한 설정이며, 서블릿 컨텍스트는 서블릿이 소속된 웹 애플리케이션의 컨텍스트이다.
      서블릿 컨피그는 서블릿 컨텍스트보다 범위가 좁다.
      ~~~
    
  - 프로파일의 통합과 추상화
  
    ~~~
    스프링 3.1에서는 프로퍼티 소스라는 개념으로 추상화하고, 프로퍼티의 저장 위치에 상관없이 동일한 API를 이용하여 가져올수 있게 한다. 
    프로퍼티 소스는 프로파일과 함께 런타임 환경정보를 구성하는 핵심 정보이다.
    Environment 타입의 런타임 오브젝트를 이용하면 일관된 방식으로 프로퍼티 정보를 가져올 수 있다.
    ~~~
  
  - 프로퍼티 소스의 사용
  
    - Environment.getProperty()
  
      - Environment 오브젝트를 빈에 주입받아서 직접 프로퍼티 값을 가져오는 메소드이다. 
  
        ~~~java
        private String adminEmail;
        
        @PostConstruct
        public void init() {
           this.adminEmail = env.getProperty("admin.email");
        }
        ~~~
  
    - PropertySourceConfigurePlaceholder와 \<context:property-placeholder\>
  
      - @PostConstruct를 사용하는 것이 번거롭다면 아래처럼 사용할 수 있다.
  
        ~~~java
        @Value("${db.username}") private String username;
        ~~~
  
  - @PropertySource와 프로퍼티 파일
  
    - 프로퍼티 파일도 프로퍼티 소스로 등록하고 사용이 가능하다.
  
      ~~~java
      @Configuration
      @PropertySource("database.properties")
      public class AppConfig { }
      ~~~
  

<br>

# <a name="2-1"></a>2.1장 공통개념



<br>
