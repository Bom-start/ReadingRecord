# ToC

- [1장 IoC 컨테이너와 DI](#01)
- [2장 IoC/DI를 위한 빈 설정 메타정보 작성](#02)



---

# <a name="01"></a>1장. IoC 컨테이너와 DI

스프링에서 제어권을 가지는 주체를 스프링 컨테이너라고 한다. 오브젝트의 생성과 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드가 아닌 이 스프링 컨테이너에서 담당한다. 그래서 이 컨테이너를 IoC 컨테이너라고 부른다.

스프링에선 IoC 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고도 부른다.

오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 스프링 컨테이너를 빈 팩토리(`BeanFactory`)라고 부른다. 그러나 스프링 컨테이너는 단순한 DI를 넘어 다양한 역할을 수행하므로 DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는데 필요한 여러가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트(`ApplicationContext`)라고 부른다. 

애플리케이션 컨텍스트는 IoC와 DI를 위한 빈 팩토리이면서 더 많은 기능을 가졌다고 이해하면 된다.

실제로도 빈팩토리와 애플리케이션 컨텍스트는 스프링에서 인터페이스로 정의되어 있는데, 애플리케이션 컨텍스트는 빈팩토리 인터페이스를 상속하는 인터페이스이다.

~~~java
public interface ApplicationContext extends ListableBeanFactory, HierachicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { }
~~~

이 `ApplicationContext`를 구현한 클래스의 오브젝트를 스프링 컨테이너 또는 IoC 컨테이너라고 부른다.

## IoC 컨테이너를 이용해 애플리케이션 만들기

![클래스 다이어그램](https://user-images.githubusercontent.com/33862991/123971471-08a24800-d9f5-11eb-953d-6c94e1acb184.png)

**요구사항**

- POJO 클래스를 이용한다.
- 메세지를 생성하여 메세지를 받아서 출력하는 프로그램을 개발한다.

**Hello.class**

~~~java
public class Hello {
   String name;
   Printer printer;
  
   public String sayHello() {
      return "Hello "+name;
   }
  
   public void print() {
      this.printer.print(sayHello());
   }
  
   public void setName(String name) {
      this.name = name;
   }
  
   public void setPrinter(Printer printer) {
      this.printer = printer;
   }
}
~~~

**Printer.class**

~~~java
public interface Printer {
   void print(String message);
}
~~~

**StringBuffer.class (StringBuffer를 사용한 Printer 구현 클래스)** 

~~~java
public class StringPrinter implements Printer {
   private StringBuffer buffer = new StringBuffer();
  
   public void print(String message) {
      this.buffer.append(message);
   }
  
   public String toString() {
      return this.buffer.toString();
   }
}
~~~

**ConsolePrinter.class (Console 출력 방식의 Printer 구현 클래스)**

~~~java
public class ConsolePrinter implements Printer {
   public void print(String message) {
      System.out.println(message);
   }
}
~~~



**코드 설명**

`Hello` 클래스는 `Printer`라는 인터페이스를 의존한다. 런타임시에 실제로 어떤 오브젝트를 사용할지를 알지 못한다. 

`Printer` 인터페이스는 두가지 구현 객체가 존재한다. `StringBuffer`를 이용해서 출력하는 클래스와 `Console`에 출력하는 클래스이다.



**설정 메타정보**

스프링의 설정 메타정보는 XML 파일이 아니다. XML에 담긴 내용을 읽어서 설정 메타정보로 활용하는건 맞지만, 스프링이 갖고있는 설정 메타정보가 XML 파일은 아니다.

스프링의 메타 정보는 `BeanDefinition` 인터페이스로 표현되는 순수한 추상정보이다. 파일의 포맷과 상관없이 스프링의 설정 메타정보의 내용을 표현했다면 무엇이든 사용가능하다. 데이터의 포맷과 구조에 맞게 읽어와 `BeanDefinition` 오브젝트로 변환하는 `BeanDefinitionReader`가 있으면 되기 때문이다.

스프링 IoC 컨테이너는 이 `BeanDefinition` 으로 만들어진 메타 정보를 담은 오브젝트를 사용하여 IoC와 DI 작업을 수행한다.

`BeanDefinition`에서 정의되는 빈 메타정보는 다음과 같다.

- 빈 아이디, 이름 : 빈 오브젝트를 구분하는 식별자
- 클래스, 클래스 이름 : 빈으로 만들 POJO 클래스 정보
- 스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
- 생성자 파라미터 값 또는 참조  : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연된 로딩 여부, 우선 빈 여부, 부모 빈 정보, 빈팩토리 이름 등



![IoC 컨테이너를 통해 애플리케이션이 만들어지는 방식](https://user-images.githubusercontent.com/33862991/123978272-b19f7180-d9fa-11eb-9d3a-7db0aa644f40.png)

스프링 애플리케이션은 POJO 클래스와 설정 메타정보를 이용하여 IoC 컨테이너가 만들어주는 오브젝트의 조합이라 할 수 있다.

**BeanDefinition을 이용한 빈 등록**

~~~java
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
~~~

**빈 등록 테스트**

~~~java
Hello hello = ac.getBean("hello", Hello.class);

assertThat(hello.sayHello(), is("Hello Spring"));
assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(1));
~~~



## IoC 컨테이너의 종류와 사용방법

### StaticApplicationContext

`StaticApplicationContext`는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 실무에서는 사용되지 않으며, 권고되지도 않는다. 테스트로 검증할때만 사용해야 한다.

### GenericApplicationContext

일반적인 애플리케이션 컨텍스트의 구현 클래스이다. `StaticApplicationContext`가 내부의 코드를 통해 빈 메타정보를 등록한다면, `GenericApplicationContext`는 외부의 리소스(XML파일 등)를 읽어들여 메타정보로 전환한다.

XML로 만든 빈 설정 메타정보

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/spring-beans-3.0.xsd">
  
  <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
  	<property name="name" value="Spring" />
    <property name="printer" value="printer" />
  </bean>
</beans>
~~~

GenericApplicationContext 테스트

~~~java
@Test
public void genericApplicationContext() {
   GenericApplicationContext ac = new GenericApplicationContext();
   XMLBeanDefinitionReader reader = new XMLBeanDefinitionReader(ac);
   reader.loadBeanDefinitions(
   		"springbook/learningtest/spring/ioc/genericApplicationContext.xml"
   );
   ac.refresh();
  
   Hello hello = ac.getBean("hello", Hello.class);
   hello.print();
  
   assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}
~~~



애플리케이션 개발하면서 `GenericApplicationContext`를 직접 사용할 일은 없다. 독립형 애플리케이션을 개발할 필요가 없기 때문이다. 그러나 독립형 애플리케이션이 필요한 일이 있다. 테스트 환경에서이다. 

JUnit 테스트는 테스트내에서 사용되도록 애플리케이션 컨텍스트를 자동으로 만들어주는데 이 때 만들어주는 애플리케이션 컨텍스트가  `GenericApplicationContext` 이다.

### GenericXmlApplicationContext

`GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 내장하고 있다. 이 때문에 XML 파일을 읽어들이고, `refresh()`를 통해 초기화하는 것까지 한 줄로 할 수 있다.

XML 파일정보는 리소스 로더가 읽을 수 있는 형식으로 `GenericXmlApplicationContext` 생성자에 넣어주면 된다.

### WebApplicationContext

스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트이다. `WebApplicationContext`는 `ApplicationContext`를 확장한 인터페이스이다.

스프링 컨테이너가 DI 작업을 수행해준다고 하지만, 그것만으로 애플리케이션을 작동시킬 수는 없다. `main()`와 같이 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작시켜야 한다.

하나의 빈 오브젝트만 호출하면, 각각의 오브젝트들끼리 DI로 연결되어 있으므로 애플리케이션이 작동될 것이다. 이 때 빈 오브젝트를 호출하는 메소드가 `getBean()`이 사용된다.

그러나 문제는 웹 애플리케이션에서는 `main()`을 호출할 방법이 없다. 그래서 웹에서는 `main()` 대신 서블릿 컨테이너가 브라우저로부터 오는 HTTP 요청을 받아서 해당 요청에 매핑되어 있는 서블릿을 실행해주는 방식으로 웹 애플리케이션을 동작시킨다.

정리하면, `main()` 역할을 하는 서블릿을 만들어두고, 미리 애플리케이션 컨텍스트를 생성해둔 다음, 요청이 서블릿으로 들어올 때마다 `getBean()`으로 필요한 빈을 가져와 정해진 메소드를 실행해주면 된다.

![웹에서 스프링 애플리케이션 기동방식](https://user-images.githubusercontent.com/33862991/123992394-8ae73800-da06-11eb-8994-a64f46d982b1.png)

서블릿 컨테이너는 클라이언트로부터 들어오는 요청을 받아서 서블릿을 동작시키는 역할을 한다. 서블릿은 웹 애플리케이션이 시작될때 미리 만들어둔 `WebApplicationContext`에게 빈 오브젝트로 구성된 애플리케이션의 기동 역할을 해줄 빈을 요청해서 받아둔다. 

### 웹 애플리케이션의 IoC 컨테이너 구성 방법

- 스프링 애플리케이션 요청을 처리하는 서블릿안에서 생성
- 웹 애플리케이션 레벨에서 생성



이에 따라 스프링 웹 애플리케이션은 2개의 WebApplicationContext 오브젝트가 생성된다.

![](resources/애플리케이션컨텍스트구성.jpeg)

두 컨텍스트가 공유해서 사용하는 빈을 담아놓는 별도의 컨텍스트를 만드는데, 이 컨텍스트가 계층구조에서 최상위에 해당하는 루트 애플리케이션 컨텍스트가 된다.

**두 개 이상의 서블릿을 구분해서 애플리케이션 컨텍스트를 계층구조로 만드는 이유**

- 전체 애플리케이션에서 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위함

## IoC 컨테이너 계층구조

모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있으며, 이를 이용하여 트리구조의 컨텍스트 계층을 만들 수 있다.

![IoC 계층구조](https://user-images.githubusercontent.com/33862991/124335938-10214700-dbd7-11eb-920c-0fe12328d4ac.png)

계층구조 안의 모든 컨텍스트는 독립적인 설정정보를 이용하여 빈 오브젝트를 만들고 각자 독립적으로 관리하는 빈이 존재한다.

DI를 위해 애플리케이션 컨텍스트가 빈을 찾을 때는 자신이 관리하는 빈에서 찾아보고 없으면 부모 컨텍스트에서 빈을 찾는다. 이 때 형제 관계의 애플리케이션 컨텍스트 또는 자식 관계의 애플리케이션 컨텍스트에서는 찾지 않는다.
위의 이미지에서 A1 에서 빈을 찾는다면, 루트 애플리케이션 컨텍스트에서까지만 찾을뿐 자식관계인 B1, 형제관계인 A2에서는 찾지않는다.   

검색 순서는 자기 자신 컨텍스트, 부모 컨텍스트 순으로 이어진다.

계층구조의 컨텍스트를 만드는 코드는 아래와 같다.

~~~java
// 부모 애플리케이션 컨텍스트 생성
String basePath = StringUtils.classPath(ClassUtils.classPackageAsResourcePAth(getClass()));
ApplicationContext parent = new GenericXmlApplicationContext(basePath + "parentContext.xml");

// 자식 애플리케이션 컨텍스트 생성
GenericApplicationContext child = new GenericApplicationContext(parent);
~~~

자식 컨텍스트를 생성할때 바라보는 노드로 부모 컨텍스트를 지정한다는 점이 중요하다.

부모 컨텍스트에서의 빈 조회를 제한 할 수도 있고, 반대로 자식 컨텍스트를 건너뛰고 직접 부모 컨텍스트로부터 빈을 조회할 수도 있다.

### 웹 애플리케이션 컨텍스트 구성 방법

- 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조
  - 가장 많이 사용되는 구성 방법
  - 웹 관련 빈은 서블릿 컨테이너에 두고,
    나머지는 루트 애플리케이션 컨텍스트에 등록
- 루트 애플리케이션 컨텍스트 단일구조
  - Spring WebMVC를 사용하지 않는 구성방법
  - 서블릿 애플리케이션 컨텍스트도 필요없음
- 서블릿 컨텍스트 단일구조
  - 스프링 외의 프레임워크를 사용하지 않거나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아닐 때 사용하는 구성 방법
  - 서블릿 컨텍스트가 부모 컨텍스트를 갖지 않으므로 루트 컨텍스트가 된다.
  - 하지만 모든 컨텍스트에서 공유되는 루트 컨텍스트와는 구별된다. (계층 구조의 차이)

### 루트 애플리케이션 컨텍스트 등록

- ContextLoaderListener 등록
- ContextConfigLocation
- contextClass

### 서블릿 애플리케이션 컨텍스트 등록

- `<servlet-name>`
- `<load-on-startup>`

<br>

# <a name="02"></a>IoC/DI를 위한 빈 설정 메타정보 작성

IoC 컨테이너가 하는 역할은 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 것. POJO 클래스와 서비스 오브젝트가 그 대상이며 이렇게 IoC 컨테이너에 의해 관리되는 오브젝트를 빈이라고 한다.

IoC 컨테이너가 빈을 관리하기 위해서는 빈의 메타정보가 필요하다. 이 메타정보를 통해 빈의 클래스와 이름을 제공받는다.

외부 파일이나 애노테이션으로부터 전용 리더를 통해 읽어들여서 BeanDefinition 타입의 오브젝트로 변환한다. 이 BeanDefinition 정보를 IoC 컨테이너가 활용한다.

BeanDefinition은 순수한 오브젝트로 표현되는 빈 생성 정보다. BeanDefinition 생성기를 사용할 수만 있다면 빈 설정 메타정보를 담은 소스는 어떻게 만들어도 상관없다.

## 빈 설정 메타정보

BeanDefinition에는 IoC 컨테이너가 빈을 만들때 필요한 핵심 정보가 담기며, 여러 개의 빈을 만드는데 재사용될 수 있다.

BeanDefinition에는 빈의 이름이나 아이디를 나타내는 정보는 포함되지 않는다. 이 때문에 메타정보는 같지만 이름은 다른 여러개의 빈 오브젝트로 재사용이 가능하다.

## 빈 등록 방법

일반적으로 XML 문서, 애노테이션 등의 외부 리소스로 빈 메타정보를 작성하고 이를 리더를 통해 ApplicationContext가 사용할 수 있는 정보로 변환하는 방법을 사용한다.

빈을 등록하는 5가지 방법이다.

### XML : \<bean> 태그

가장 단순하면서 가장 강력한 빈 설정방법.

`<bean>`을 이용하면 스프링 빈 메타정보의 거의 모든 항목을 지정하는 것이 가능하다.

id와 class 두 개의 애트리뷰트를 사용한다. id는 생략이 가능하다.

~~~xml
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
	...
</bean>
~~~

bean은 다른 빈의 \<property> 태그안에 정의될수도 있다. 이때는 id를 지정하지 않는다. 이렇게 다른 빈의 설정 안에서 정의되는 빈을 내부 빈(Inner Bean)이라 한다.

~~~xml
<bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
   <property>
      <bean class="springbook.learningtest.spring.ioc.bean.StringPrinter" />
   </property>
</bean>
~~~

### XML : 네임스페이스와 전용 태그

스프링은 기술적인 설정과 기반 서비스를 빈으로 등록할때를 위해 의미가 잘 드러나는 네임스페이스와 태그를 가진 설정 방법을 제공한다.

그냥 \<bean> 태그를 사용한 예이다.

~~~xml
<bean id="mypointcut"
      class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
   <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))" />
</bean>
~~~

위의 \<bean>태그로 작성된 포인트컷을 \<aop:pointcut> 태그로 바꿀수 있다.

~~~xml
<aop:pointcut id="mypointcut"
              expression="execution(* *..*SErviceImpl.upgrade*(..))" />
~~~

\<bean>태그로 선언한것과 동일하게 빈 설정 메타정보로 변환하였다. 그러나 네임스페이스(`aop`), 전용 애트리뷰트(`pointcut`)를 이용해 선언했기 때문에 내용이 직관적으로 드러난다.

또 여러개의 \<bean> 태그를 네임스페이스를 이용해서 한줄로 처리할 수도 있다.

~~~xml
<bean id="userController" class="com.mycompany.user.UserController">
	<property name="service" ref="userService" />
</bean>
<bean id="userService" class="com.mycompany.user.UserService">
	<property name="dao" ref="userDao" />
</bean>
<bean id="userDao" class="com.mycompany.user.UserDao">
</bean>
~~~

 위의 \<bean> 태그를 한 줄로 대체하는 예이다.

~~~xml
<aop:module id-prefix="user" class-prefix="User" package="com.mycompany.user" />
~~~

### 자동인식을 이용한 빈 등록 : 스테레오 타입 애노테이션과 빈 스캐너

빈 스캐닝을 통해 특정 애노테이션이 붙은 클래스를 자동으로 찾아서 빈으로 등록해주기도 한다. 이 때 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너라고 한다.

예제 코드이다.

~~~java
@Component
public class AnnotatedHello {
   ...
}
~~~

애노테이션 `@Component`가 붙어있어서 빈 스캐너가 이를 감지하여 자동으로 빈으로 등록해준다. 이 때 클래스이름이 빈의 id가 되며, 위의 예제코드에서는 `annotetedHello`로 등록된다.

만약 빈의 이름을 지정하고 싶다면 애노테이션의 파라미터로 넣어주면 된다.

~~~java
@Component("myAnnotatedHello")
public class AnnotatedHello {
   ...
}
~~~

정말 빈이 등록되었는지 확인하는 테스트 코드이다.

~~~java
@Test
public void simpleBeanScanning() {
   ApplicationContext ctx = new AnnotationConfigApplicationContext(
      "springbook.learningtest.spring.ioc.bean");
  
   AnnotetedHello hello = ctx.getBean("annotatedHello", AnnotatedHello.class);
  
   assertTrue(hello, is(notNullValue()));
}
~~~

### 자바 코드에 의한 빈 등록 : @Configuration 클래스의 @Bean 메소드

스프링은 코드를 이용해서 오브젝트를 생성하고 DI 진행하는 방식으로 만들어진 오브젝트를 빈으로 쓸 수 있는 방법을 제공한다. 

~~~java
@Configuration
public class AnnotatedHelloConfig {
   @Bean
   public AnnotatedHello annotatedHello() {
      return new AnnotatedHello();
   }
}
~~~

XML 문서의 \<beans>를 `@Configuration` 클래스로, \<bean>을 `@Bean` 메소드로 대응한다.

위의 코드를 통해서 메소드뿐 아니라 `@Configuration` 애노테이션이 붙은 클래스 자신도 빈으로 등록이 된다. 이는 `@Component`를 통한 빈 등록과 같다.

**자바 코드에 의한 설정의 장점**

- 컴파일러/IDE를 통한 타입 검증이 가능
- 자동완성 같은 IDE 지원을 이용할 수 있다.
- 이해하기 쉽다.
- 복잡한 빈 설정을 손쉽게 가능

### 자바 코드에 의한 빈 등록 : 일반 빈 클래스의 @Bean 메소드

클래스에 `@Configuration`을 붙이지 않아도 메소드에 `@Bean`을 붙여서 메소드를 빈으로 등록해서 사용할 수 있다.

`@Configuration`이 붙은 클래스에서 `@Bean`이 붙은 메소드는 싱글톤이기 때문에 여러번 호출돼도 하나의 오브젝트만 리턴되는 것이 보장된다. 하지만 일반 클래스에 `@Bean` 을 사용한 경우는 DI 설정을 위해 Bean 메소드를 호출할때마다 매번 다른 오브젝트를 받게 된다.

~~~java
public class HelloService {
   @Bean
   public Hello hello() {
      Hello hello = new Hello();
      hello.setPrinter(printer());
      return hello;
   }
}
~~~

따라서 일반 빈 클래스에서 `@Bean` 애노테이션을 사용하면서 DI를 위해 다른 메소드를 호출할때는 해당 메소드를 생성자로 주입받아서 싱글톤 오브젝트로 생성해두고 이를 가져다 사용하는 방식으로 해결해야한다.

~~~java
public class HelloService {
   private Printer printer;
  
   public void setPrinter(Printer printer) {
      this.printer = printer;
   }
  
   @Bean
   public Hello hello() {
      Hello hello = new Hello();
      hello.setPrinter(this.printer);
      return hello;
   }
}
~~~

<br>

## 빈 등록 메타정보 구성 전략

- **XML 단독 사용**
  - 모든 설정 정보를 자바 코드에서 분리하고 순수한 POJO 코드를 유지할 수 있는 방법
- **XML과 빈 스캐닝의 혼용**
- **XML 없이 빈 스캐닝 단독 사용**
  - 모든 빈의 정보가 자바 코드에 담겨있으므로 타입 검증의 이점이있다.

<br>



