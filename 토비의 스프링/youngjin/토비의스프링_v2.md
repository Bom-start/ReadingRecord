# ToC

- [1장 IoC 컨테이너와 DI](#01)



---

# <a name="01"></a>1장. IoC 컨테이너와 DI

스프링에서 제어권을 가지는 주체를 스프링 컨테이너라고 한다. 오브젝트의 생성과 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드가 아닌 이 스프링 컨테이너에서 담당한다. 그래서 이 컨테이너를 IoC 컨테이너라고 부른다.

스프링에선 IoC 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고도 부른다.

오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 스프링 컨테이너를 빈 팩토리(`BeanFactory`)라고 부른다. 그러나 스프링 컨테이너는 단순한 DI를 넘어 다양한 역할을 수행하므로 DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는데 필요한 여러가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트(`ApplicationContext`)라고 부른다. 

애플리케이션 컨텍스트는 IoC와 DI를 위한 빈 팩토리이면서 더 많은 기능을 가졌다고 이해하면 된다.

실제로도 빈팩토리와 애플리케이션 컨텍스트는 스프링에서 인터페이스로 정의되어 있는데, 애플리케이션 컨텍스트는 빈팩토리 인터페이스를 상속하는 인터페이스이다.

~~~java
public interface ApplicationContext extends ListableBeanFactory, HierachicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { }
~~~

이 `ApplicationContext`를 구현한 클래스의 오브젝트를 스프링 컨테이너 또는 IoC 컨테이너라고 부른다.

## IoC 컨테이너를 이용해 애플리케이션 만들기

![클래스 다이어그램](https://user-images.githubusercontent.com/33862991/123971471-08a24800-d9f5-11eb-953d-6c94e1acb184.png)

**요구사항**

- POJO 클래스를 이용한다.
- 메세지를 생성하여 메세지를 받아서 출력하는 프로그램을 개발한다.

**Hello.class**

~~~java
public class Hello {
   String name;
   Printer printer;
  
   public String sayHello() {
      return "Hello "+name;
   }
  
   public void print() {
      this.printer.print(sayHello());
   }
  
   public void setName(String name) {
      this.name = name;
   }
  
   public void setPrinter(Printer printer) {
      this.printer = printer;
   }
}
~~~

**Printer.class**

~~~java
public interface Printer {
   void print(String message);
}
~~~

**StringBuffer.class (StringBuffer를 사용한 Printer 구현 클래스)** 

~~~java
public class StringPrinter implements Printer {
   private StringBuffer buffer = new StringBuffer();
  
   public void print(String message) {
      this.buffer.append(message);
   }
  
   public String toString() {
      return this.buffer.toString();
   }
}
~~~

**ConsolePrinter.class (Console 출력 방식의 Printer 구현 클래스)**

~~~java
public class ConsolePrinter implements Printer {
   public void print(String message) {
      System.out.println(message);
   }
}
~~~



**코드 설명**

`Hello` 클래스는 `Printer`라는 인터페이스를 의존한다. 런타임시에 실제로 어떤 오브젝트를 사용할지를 알지 못한다. 

`Printer` 인터페이스는 두가지 구현 객체가 존재한다. `StringBuffer`를 이용해서 출력하는 클래스와 `Console`에 출력하는 클래스이다.



**설정 메타정보**

스프링의 설정 메타정보는 XML 파일이 아니다. XML에 담긴 내용을 읽어서 설정 메타정보로 활용하는건 맞지만, 스프링이 갖고있는 설정 메타정보가 XML 파일은 아니다.

스프링의 메타 정보는 `BeanDefinition` 인터페이스로 표현되는 순수한 추상정보이다. 파일의 포맷과 상관없이 스프링의 설정 메타정보의 내용을 표현했다면 무엇이든 사용가능하다. 데이터의 포맷과 구조에 맞게 읽어와 `BeanDefinition` 오브젝트로 변환하는 `BeanDefinitionReader`가 있으면 되기 때문이다.

스프링 IoC 컨테이너는 이 `BeanDefinition` 으로 만들어진 메타 정보를 담은 오브젝트를 사용하여 IoC와 DI 작업을 수행한다.

`BeanDefinition`에서 정의되는 빈 메타정보는 다음과 같다.

- 빈 아이디, 이름 : 빈 오브젝트를 구분하는 식별자
- 클래스, 클래스 이름 : 빈으로 만들 POJO 클래스 정보
- 스코프 : 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조 : DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
- 생성자 파라미터 값 또는 참조  : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연된 로딩 여부, 우선 빈 여부, 부모 빈 정보, 빈팩토리 이름 등



![IoC 컨테이너를 통해 애플리케이션이 만들어지는 방식](https://user-images.githubusercontent.com/33862991/123978272-b19f7180-d9fa-11eb-9d3a-7db0aa644f40.png)

스프링 애플리케이션은 POJO 클래스와 설정 메타정보를 이용하여 IoC 컨테이너가 만들어주는 오브젝트의 조합이라 할 수 있다.

**BeanDefinition을 이용한 빈 등록**

~~~java
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
ac.registerBeanDefinition("hello2", helloDef);
~~~

**빈 등록 테스트**

~~~java
Hello hello = ac.getBean("hello", Hello.class);

assertThat(hello.sayHello(), is("Hello Spring"));
assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(1));
~~~



## IoC 컨테이너의 종류와 사용방법

### StaticApplicationContext

`StaticApplicationContext`는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 실무에서는 사용되지 않으며, 권고되지도 않는다. 테스트로 검증할때만 사용해야 한다.

### GenericApplicationContext

일반적인 애플리케이션 컨텍스트의 구현 클래스이다. `StaticApplicationContext`가 내부의 코드를 통해 빈 메타정보를 등록한다면, `GenericApplicationContext`는 외부의 리소스(XML파일 등)를 읽어들여 메타정보로 전환한다.

XML로 만든 빈 설정 메타정보

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/spring-beans-3.0.xsd">
  
  <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
  	<property name="name" value="Spring" />
    <property name="printer" value="printer" />
  </bean>
</beans>
~~~

GenericApplicationContext 테스트

~~~java
@Test
public void genericApplicationContext() {
   GenericApplicationContext ac = new GenericApplicationContext();
   XMLBeanDefinitionReader reader = new XMLBeanDefinitionReader(ac);
   reader.loadBeanDefinitions(
   		"springbook/learningtest/spring/ioc/genericApplicationContext.xml"
   );
   ac.refresh();
  
   Hello hello = ac.getBean("hello", Hello.class);
   hello.print();
  
   assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}
~~~



애플리케이션 개발하면서 `GenericApplicationContext`를 직접 사용할 일은 없다. 독립형 애플리케이션을 개발할 필요가 없기 때문이다. 그러나 독립형 애플리케이션이 필요한 일이 있다. 테스트 환경에서이다. 

JUnit 테스트는 테스트내에서 사용되도록 애플리케이션 컨텍스트를 자동으로 만들어주는데 이 때 만들어주는 애플리케이션 컨텍스트가  `GenericApplicationContext` 이다.

### GenericXmlApplicationContext

`GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 내장하고 있다. 이 때문에 XML 파일을 읽어들이고, `refresh()`를 통해 초기화하는 것까지 한 줄로 할 수 있다.

XML 파일정보는 리소스 로더가 읽을 수 있는 형식으로 `GenericXmlApplicationContext` 생성자에 넣어주면 된다.

### WebApplicationContext

스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트이다. `WebApplicationContext`는 `ApplicationContext`를 확장한 인터페이스이다.

스프링 컨테이너가 DI 작업을 수행해준다고 하지만, 그것만으로 애플리케이션을 작동시킬 수는 없다. `main()`와 같이 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작시켜야 한다.

하나의 빈 오브젝트만 호출하면, 각각의 오브젝트들끼리 DI로 연결되어 있으므로 애플리케이션이 작동될 것이다. 이 때 빈 오브젝트를 호출하는 메소드가 `getBean()`이 사용된다.

그러나 문제는 웹 애플리케이션에서는 `main()`을 호출할 방법이 없다. 그래서 웹에서는 `main()` 대신 서블릿 컨테이너가 브라우저로부터 오는 HTTP 요청을 받아서 해당 요청에 매핑되어 있는 서블릿을 실행해주는 방식으로 웹 애플리케이션을 동작시킨다.

정리하면, `main()` 역할을 하는 서블릿을 만들어두고, 미리 애플리케이션 컨텍스트를 생성해둔 다음, 요청이 서블릿으로 들어올 때마다 `getBean()`으로 필요한 빈을 가져와 정해진 메소드를 실행해주면 된다.

![웹에서 스프링 애플리케이션 기동방식](https://user-images.githubusercontent.com/33862991/123992394-8ae73800-da06-11eb-8994-a64f46d982b1.png)

서블릿 컨테이너는 클라이언트로부터 들어오는 요청을 받아서 서블릿을 동작시키는 역할을 한다. 서블릿은 웹 애플리케이션이 시작될때 미리 만들어둔 `WebApplicationContext`에게 빈 오브젝트로 구성된 애플리케이션의 기동 역할을 해줄 빈을 요청해서 받아둔다. 

## IoC 컨테이너 계층구조

모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있으며, 이를 이용하여 트리구조의 컨텍스트 계층을 만들 수 있다.

![IoC 계층구조](https://user-images.githubusercontent.com/33862991/124335938-10214700-dbd7-11eb-920c-0fe12328d4ac.png)

계층구조 안의 모든 컨텍스트는 독립적인 설정정보를 이용하여 빈 오브젝트를 만들고 각자 독립적으로 관리하는 빈이 존재한다.

DI를 위해 애플리케이션 컨텍스트가 빈을 찾을 때는 자신이 관리하는 빈에서 찾아보고 없으면 부모 컨텍스트에서 빈을 찾는다. 이 때 형제 관계의 애플리케이션 컨텍스트 또는 자식 관계의 애플리케이션 컨텍스트에서는 찾지 않는다.
위의 이미지에서 A1 에서 빈을 찾는다면, 루트 애플리케이션 컨텍스트에서까지만 찾을뿐 자식관계인 B1, 형제관계인 A2에서는 찾지않는다.   

검색 순서는 자기 자신 컨텍스트, 부모 컨텍스트 순으로 이어진다.

계층구조의 컨텍스트를 만드는 코드는 아래와 같다.

~~~java
// 부모 애플리케이션 컨텍스트 생성
String basePath = StringUtils.classPath(ClassUtils.classPackageAsResourcePAth(getClass()));
ApplicationContext parent = new GenericXmlApplicationContext(basePath + "parentContext.xml");

// 자식 애플리케이션 컨텍스트 생성
GenericApplicationContext child = new GenericApplicationContext(parent);
~~~

자식 컨텍스트를 생성할때 바라보는 노드로 부모 컨텍스트를 지정한다는 점이 중요하다.

부모 컨텍스트에서의 빈 조회를 제한 할 수도 있고, 반대로 자식 컨텍스트를 건너뛰고 직접 부모 컨텍스트로부터 빈을 조회할 수도 있다.

### 웹 애플리케이션 컨텍스트 구성 방법

- 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조
  - 가장 많이 사용되는 구성 방법
  - 웹 관련 빈은 서블릿 컨테이너에 두고,
    나머지는 루트 애플리케이션 컨텍스트에 등록
- 루트 애플리케이션 컨텍스트 단일구조
  - Spring WebMVC를 사용하지 않는 구성방법
  - 서블릿 애플리케이션 컨텍스트도 필요없음
- 서블릿 컨텍스트 단일구조
  - 스프링 외의 프레임워크를 사용하지 않거나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아닐 때 사용하는 구성 방법
  - 서블릿 컨텍스트가 부모 컨텍스트를 갖지 않으므로 루트 컨텍스트가 된다.
  - 하지만 모든 컨텍스트에서 공유되는 루트 컨텍스트와는 구별된다. (계층 구조의 차이)

### 루트 애플리케이션 컨텍스트 등록

- ContextLoaderListener 등록
- ContextConfigLocation
- contextClass

### 서블릿 애플리케이션 컨텍스트 등록

- `<servlet-name>`
- `<load-on-startup>`

