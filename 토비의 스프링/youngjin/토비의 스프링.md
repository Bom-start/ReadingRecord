# ToC

- [스프링 기본개념 및 학습방법](#0)
  - 스프링이란 무엇인가
  - 스프링의 성공요인
  - 스프링 학습방법
- [오브젝트와 의존관계](#1)
  - 자바 빈(Java Bean)
  - 관심사의 분리
  - 리팩토링
  - 디자인 패턴
  - 원칙과 패턴
- [테스트](#2)
  - 작은 단위의 테스트
  - JUnit
  - 테스트 주도개발(TDD)

<hr>

# <a name="0"></a>0. 스프링 기본개념 및 학습방법

## 스프링이란 무엇인가

스프링은 자바 엔터프라이즈(Java EE) 애플리케이션 개발에 사용되는 애플리케이션 프레임워크.

### 스프링 컨테이너

스프링은 스프링 컨테이너 또는 애플리케이션 컨텍스트라고 불리는 스프링 런타임 엔진을 제공하고, 스프링 컨테이너가 설정정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리한다.

### IoC/DI

스프링 프레임워크의 근간인 IoC/DI는 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델이다.

### 서비스 추상화

스프링은 환경이나 서버, 특정 기술에 종속되지 않고 이식성이 뛰어난 유연한 애플리케이션을 만들수 있는데, 이를 가능케 하는것이 서비스 추상화이다.

### AOP

애플리케이션을 구성하는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델이다.

<br>

## 스프링의 성공요인

### 단순함

스프링은 객체지향의 장점을 개발자들이 살릴수 있도록 도와주는 도구이다. 스프링은 가장 단순한 객체지향적인 개발 모델인 POJO 프로그래밍을 주장한다.

### 유연성

스프링은 유연성과 확장성이 매우 뛰어난 프레임워크이다. 유연성이 뛰어나서 다른 프레임워크와 편리하게 접목돼서 사용될수있다. 

스프링은 기존 아키텍처와 설계, 코드를 유지하면서 발전해왔기에 스프링을 자신만의 프레임워크로 만들어서 사용하는것도 가능하다.

<br>

## 스프링 학습 방법

### 스프링 핵심가치, 원리에 대한 이해

스프링에는 가장 중요한 핵심 가치와 그것을 가능하도록 돕는 <b>세가지 핵심기술</b>이 있다. 그리고 스프링이 강조하는 중요한 <b>프로그래밍 모델</b>이 있다. 이를 자세히 공부하고 일관된 방식으로 스프링을 이해하는 것이 중요하다.

### 스프링 기술에 대한 지식과 선택 기준 정립

상황에 따라 스프링이 제공하는 기술을 선택할 수 있어야한다. 스프링은 매우 범용적인 프레임워크이다. 스프링이 제공하는 기술의 종류와 접근 방법에 대해 알아보고 상황에 맞는 최선의 기술과 접근 방법을 선택할 수 있어야한다.

### 스프링 적용과 확장

스프링을 어떻게 애플리케이션 개발에 적용하는지 응용 방법과 확장방법을 공부해야한다.

<br>

# <a name="1"></a>1장. 오브젝트와 의존관계

스프링을 이해하기 위해서는 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되어 지고, 소멸되기까지의 전 과정을 생각할 수 있어야 한다. 

이 과정을 통해 오브젝트를 어떻게 잘 설계할 수 있는가로 발전하게 되고, 객체지향의 기초와 원칙을 기반으로 다양한 목적을 위해 재활용 가능한 설계 방법인 **디자인 패턴**, 더 깔끔한 구조로 개선해나가는 작업인 **리팩토링**, 의도한대로 잘 작동하는지 검증하기 위한 **단위 테스트**와 같이 오브젝트 설계와 구현에 관한 여러 응용 기술과 지식으로 연결된다.

### 자바 빈

다음 두가지 관례를 따라 만들어진 오브젝트.

- 디폴트 생성자
  - 자바 빈은 파라미터가 없는 디폴트 생성자를 갖고있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티
  - 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메서드(setter)와 get으로 시작하는 접근자 메서드(getter)를 이용해 수정 또는 조회할 수 있다.

<br>

## DAO 분리

### 관심사의 분리

1. DB 연결을 위한 `Connection`을 어떻게 가져올까라는 관심
2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 `Statement`를 만들고 실행하는 것. 파라미터로 넘어온 사용자 정보를 `Statement`에 바인딩시키고, `Statement`에 담긴 SQL을 DB를 통해 실행시키는 것.
3. 작업이 끝나면 사용한 리소스인 `Statement`와 `Connection` 오브젝트를 닫아줘서 소중한 공유

## 리팩토링

기존의 코드를 외부의 동작방식의 변화없이 내주 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면, 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고 변화에 효율적으로 대응할 수 있다.

## 디자인패턴

디자인패턴은 소프트웨어 설계시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션.

디자인패턴은 주로 객체지향적인 설계가 많다. 그러다보니 디자인패턴의 설계 구조가 서로 비슷한데, 이는 객체지향적 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문.

- 클래스 상속
- 오브젝트 합성

백엔드 개발자라면 디자인 패턴에 대해 학습을 해야 하며, [GoF의 다지인 패턴](http://aladin.kr/p/S6Nzq) 또는 [Head First Design Pattern](http://aladin.kr/p/7FHKt)를 추천.

### 	- 템플릿 메서드 패턴

**상속**을 통해서 슈퍼클래스의 기능을 확장할때 사용하는 대표적인 디자인 패턴.

**<u>변하지 않는 기능은 슈퍼클래스에 만들어두고, 가변적인 기능은 서브클래스</u>**에서 만든다. 

슈퍼클래스에서는 추상 메서드나 오버라이드 가능한 메서드를 정의하여 이를 활용해 코드의 알고리즘을 담는 템플릿 메서드를 만든다.

슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만든 메서드를 훅(Hook) 메서드라고 한다.

~~~java
public abstract class Super {
   public void templateMethod(){
      hookMethod();
      abstractMethod();
   }

   protected void hookMethod(){
      System.out.println("선택적으로 오버라이딩 가능");
   }

   protected abstract void abstractMethod();  // 오버라이딩을 강제하는 메서드(추상 메서드)
}
~~~

~~~java
public class Sub1 extends Super {
   protected void hookMethod(){

   }

   @Override
   protected void abstractMethod() {

   }
}
~~~

### 	- 팩토리 메서드 패턴

팩토리 메서드 패턴도 상속을 통해 기능 확장하는 패턴.

슈퍼클래스에서는 어떤 클래스의 오브젝트를 만들어 반환할지 관심을 갖지않는다. 덕분에 서브클래스에서는 다양한 방법으로 오브젝트를 생성하는 메서드를 재정의할 수 있다.

서브클래스에서 오브젝트 생성 방법과 클래스를 결정할수있도록 미리 정의해둔 메서드를 팩토리 메서드라고 한다.

오브젝트를 생성하는 기능을 갖는 메서드를 팩토리 메서드라고 표현하는데, 이 때의 팩토리 메서드와 팩토리 메서드 패턴에서 팩토리 메서드는 서로 다르다. 주의 할 것!

<br>

## 원칙과 패턴

### 개방 폐쇄 원칙 (OCP, Open-Closed Principle)

OCP를 이용하면, 리팩토링 작업의 특징과 최종적으로 개선된 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있다.

OPC는 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙중 하나이다.

### 객체지향 설계 원칙(SOLID)

- 단일 책임 원칙(SRP, The Single Responsibility Principle)
- 개방 폐쇄 원칙(OCP, The Open Closed Principle)
- 라스코프 치환 원칙(LSP, The Kiskov Substitution Principle)
- 인터페이스 분리 원칙(IPS, The Interface Segregation Principle)
- 의존관계 역전 원칙(The Dependency Inversion Principle)

### 높은 응집도

하나의 모듈, 클래스가 **<u>하나의 책임 또는 관심사에만 집중</u>**되어 있다는 뜻이다. 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀있지 않으며, 하나의 공통 관심사는 한 클래스에 모여있다.

단점으로는 해당 모듈에서 변화가 발생할때 수정해야할 부분이 많다. 따라서 모듈의 일부부만 변경되더라도 모듈 전체에서 어떤 부분이 바뀌는지를 확인해야한다.

### 낮은 결합도

결합도란 하나의 오브젝트가 변경이 일어날 때, 관계를 맺는 다른 오브젝트에게 변화를 요구하는 정도를 의미한다.

낮은 결합도는 높은 응집도보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이다.

정리하면 하나의 변경이 발생할 때, 여러 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.

<br>

# <a name="2"></a>2장. 테스트

테스트란, 개발자가 의도한 대로 코드가 동작하는지 확인하기 위한 작업이다. 만약 이 결과가 의도대로 나오지 않는 경우에 코드 또는 설계에 결함이 있을수 있다. 이 때 디버깅을 통해 결함을 제거하고 테스트가 성공하면 결함이 제거됐다는 확신을 얻을 수 있다.

### UI 환경에서의 테스트의 문제

로그인 기능을 검증하기 위해서 브라우저로 테스트한다고 가정하면 로그인 기능 하나를 테스트하기위해서 전체 웹 서버를 동작시키고, 아이디와 패스워드를 폼에 입력해서 로그인 성공, 또는 로그인 실패가 되는지를 확인해야 한다. 한 번의 케이스를 할 때마다 로그인과 로그아웃을 반복해야 하는데 이런 테스트는 매우 비효율적일뿐더러 오히려 다른 에러를 발견이라도 하면 원래 검증하려고 했던 로그인 기능을 테스트하지 못할수도 있다.

## 작은 단위의 테스트

테스트의 단위는 작을 수록 좋다고 한다. 결합도가 복잡할 경우, 테스트하려는 대상이 모호해질수 있으므로 최대한 작게 쪼개어 단위 테스트를 하는게 테스트 대상에만 집중할 수 있다. 이를 **단위 테스트(Unit Test)** 라고 한다.

## JUnit

JUnit은 스프링에서 제공하는 테스트 프레임워크이다.

모든 테스트 메서드는 `main()`처럼 각각 제어권을 갖고 있으며, 독립적으로 실행하여 테스트를 진행할 수 있다. <u>애노테이션으로 `@Test`만 붙히면 된다.</u>

~~~java
public class UserDaoTest {
   @Test
   public void addAndGet() throws SQLException {
      ApplicationContext context 
         = new ClassPathXmlApplicationContext("");
   }
}
~~~

### 예외 테스트

예외가 정상적으로 throw 되는지 확인할 수 있다.

~~~java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {
   ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
  
   UserDao dao = context.getBean("userDao", UserDao.class);
   dao.deleteAll();
   assertThat(dao.getCount(), is(0));
}
~~~

이 테스트 메서드를 실행했을때, `EmptyResultDataAccessException` 이 발생한다면 테스트가 성공할 것이고, 그렇지 않다면 성공하지 않을것이다.

예외가 정상적으로 발생하는지 테스트하는 방법은 아래의 방법도 있다.

~~~java
@Test
@DisplayName("StringIndexOutOfBoundsException 발생하는 테스트")
void 요구사항3_2() {
   String data = "abc";
   assertThatThrownBy(() -> {
      char result = data.charAt(4);
      assertThat(result).isEqualTo('a');
   }).isInstanceOf(StringIndexOutOfBoundsException.class);
}
~~~

[AssertJ](https://www.baeldung.com/assertj-exception-assertion) 라는 테스트 라이브러리의 테스트 메서드 `assertThatThrownBy()`를 사용한 예제코드이다.

## 테스트 주도개발(TDD, Test Driven Development)

테스트를 먼저 하고, 테스트가 성공하면 프로덕션 코드로 이어가는 개발 방식을 이야기한다.

> 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
>
> TDD 기본원칙

TDD는 작업의 주기를 짧게 가져가는게 중요하다고 한다. 그러다보니 TDD를 하다보면 자연스럽게 단위 테스트를 하게된다.

## User Service 테스트 코드 작성하기

현재 진행중인 프로젝트는 Spring Boot는 Test 의존성을 갖고있으므로 특별한 라이브러리를 추가하지 않아도 JUnit을 사용할 수 있다.

JUnit을 이용하여 User를 등록하고, 삭제하는 테스트를 진행했다. 

![](https://www.w3schools.in/wp-content/uploads/2019/03/MVC-Architecture.png)

DAO나 컨트롤러가 아닌 서비스를 테스트 대상으로 선택한 이유는 컨트롤러는 페이지 View와 통신하는 역할을 하는데 현재 진행중인 프로젝트에서는 View를 구현하지 않았으므로 컨트롤러 보다 위의 MVC 아키텍쳐에서 Model에 해당하는 부분에 대한 테스트가 필요해보였다.

DB와 통신하는 DAO보다는 실제 서비스에 대한 테스트가 더 유효할것이라는 생각을 했다. 

사용자 등록 **테스트 목적은 DB와 직접 통신해서 기대했던 결과가 진행되는지**를 알아보게 된다.

~~~java
import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
class UserServiceImplTest {
  
   @Autowired
   UserService userService;

   @Test
   @DisplayName("사용자 등록 테스트")
   void createUser() {
      // given
      User user = new User();
      user.setId("testId");
      user.setName("testName");
      user.setPassword("testPw");

      // when
      userService.createUser(user);

      // then
      String expected = user.getName();
      String actual = userService.getUser(user.getId()).getName();

      System.out.println("\nexpected : "+expected);
      System.out.println("actual : "+actual+"\n");

      assertEquals(actual,expected);
   }
}

~~~

테스트에서 사용한 어노테이션으로 `@SpringBootTest`를 사용했는데, 이 애노테이션을 테스트 대상 클래스에 작성해야 단위 테스트에서도 웹 서버가 실행되면서 클래스 내부에서 선언한 빈 객체들을 스프링에 주입해서 테스트를 진행할 수 있다.

그럼 단위 테스트를 진행하는 순간 스프링부트 웹 서버가 동작하면서 `@Autowired`로 선언한 객체들을 주입받는다. 여기서 주입받은 Bean으로 `UserService` 인스턴스를 사용할 수 있게된다.

단위 테스트 대상은 `@Test`가 붙은 메서드이다.

테스트는 Martin Fowler가 [언급](https://martinfowler.com/bliki/GivenWhenThen.html)한 given-when-then 으로 작성했다. 

- **given**
  - 테스트를 위해 준비하는 파트이다.
  - 테스트의 대상에 파라미터가 필요하다면, 그 파라미터에 들어갈 인자를 정의하는 파트이다.
- **when**
  - 테스트하고자 하는 대상의 파트이다.
- **then**
  - JUnit, AssertJ와 같은 테스트 라이브러리를 이용하여 실제 테스트를 하는 역할이다.
  - 기대하는 객체(`expected`)와 실제 객체간 비교(`actual`)를 진행한다. 

위의 코드를 실행한 단위 테스트의 결과는 다음과 같다.

![](/Users/Andy/IdeaProjects/ReadingRecord/토비의 스프링/youngjin/resources/result-test.png)

`@DisplayName` 애노테이션은 테스트 이름을 작성해서 테스트 결과에서 어떤 테스트를 진행했는지 보여주는 역할을 수행한다.

<br>

# 3장. 템플릿

요점

1. 스프링에서 DI와 IOC
2. 개방-폐쇄 원칙(OCP)
3. 전략 패턴과 전략 패턴을 사용하면 좋은 점
4. 스프링은 왜 DI를 위해서 인터페이스를 사용하도록 강조하는지? 꼭 인터페이스로만 만들어야 하는지?

### 개방-폐쇄 원칙 (Open-Closed Principle)

객체지향의 5대원칙중 하나이다.

객체지향의 5대원칙은 아래와 같다.

- 단일 책임 원칙 (Single Responsibility Principle)
- 개방 폐쇄 원칙 (Open Closed Principle)
- 리스코프 치환 법칙 (Liskov Substitution Principle)
- 인터페이스 분리 원칙 (Interface Segragation Principle)
- 의존 역전 원칙 (Dependency Inversion Principle)

개방 폐쇄 원칙은 객체는 확장에 열려있어야 하며, 수정에 대해서는 닫혀있어야함을 의미한다.

**확장에 열려있다.**

모듈의 확장성을 보장하는 것을 의미한다. 새로운 변경사항이 발생했을때 유연하게 코드를 추가 또는 수정할 수 있다.

**수정에 닫혀있다.**

객체를 직접적으로 수정하는건 제한해야 한다. 기능이 추가되거나 수정할때마다 객체를 직접 수정해야한다면 비용의 증가로 이어진다.

### OCP를 구현하는 디자인 패턴

### 스트래티지 패턴 (Strategy Pattern)

![](https://mblogthumb-phinf.pstatic.net/MjAxOTA4MTFfMjQ4/MDAxNTY1NTI5ODUyMjc1.-klmjNH5olJ9zLHTQVx6-yEFU3CcdrS4KDsuNhF-ykcg.glRiMljkP-GOdbL7ypY0mgUlywuN-wYxO-wQ6f4g-mYg.JPEG.jwyoon25/56.JPG?type=w800)

위와 같은 구조에서 `Client`가 다른 서버를 사용해야 할 경우, `Client` 클래스를 변경해야 한다. 하지만 이 때 `Client`가 `Server`를 직접 의존하는게 아니라 `ClientInterface`라는 인터페이스를 의존하고, 서버 클래스들은 이 인터페이스를 상속받는다면 `Client`가 어떤 서버를 이용하든 `Client` 클래스를 바꾸지 않아도 된다.

그렇게 바꾼 구조는 다음과 같다.

![](https://mblogthumb-phinf.pstatic.net/MjAxOTA4MTFfMjc0/MDAxNTY1NTMwMTQ5NTUz.9ngRA5Rgji0ddHk2gXA5BLKuxMEPgapkyRPwloftKAog.LYG0BN4zP126V3kP0FI2HoE1QpQfejzLYR5eHyi6uJIg.JPEG.jwyoon25/57.JPG?type=w800)

이런 패턴을 전략 패턴이라 한다. `Client`는 목적에 맞는 전략(서버)를 선택할 수 있기 때문이다.

`Client`는 `ClientInterface`를 의존하지만, 실제 런타임에서 사용되는 객체는 `Server` 클래스이므로 `Client` 클래스에 대한 변경없이 서버를 유연하게 변경하며 사용할 수 있다.

### 템플릿 메서드 패턴 (Template Method Pattern)

전략 패턴을 설명하면서 인터페이스를 사용했는데, 템플릿 메서드 패턴도 역시 추상화를 이용한다.

![](https://mblogthumb-phinf.pstatic.net/MjAxOTA4MTFfMTcw/MDAxNTY1NTMxNDIyMDk4.ZeRycNdSIrQcF4E61UV5YqLxrniww7ckKzJJQ03qSGkg.rysgWpFfOIDhV4ORz72shjAJBQ_6o9Zv8_Gqfxdy6Ugg.JPEG.jwyoon25/58.JPG?type=w800)

정책을 구현하는 함수들을 갖고있는 `Policy`클래스를 상속해서 특정 함수를 오버라이딩한 하위 객체인 `PolicyImpl`클래스이다.

### 스프링에서 DI를 구현하기 위해 인터페이스를 사용하는 이유

~~~java
public class GameRule {
   private final NumberGenerator numberGenerator;
  
   public GameRule(NumberGenerator numberGenerator){
      this.numberGenerator = numberGenerator;
   }
}
~~~

`GameRule` 클래스는 `NumberGenerator`라는 클래스를 의존한다. 여기서 `NumberGenerator`는 인터페이스로 구성되어 있다.

~~~java
public interface NumberGenerator {
   int getRandom();
}
~~~

실제 `GameRule` 클래스에서 사용되는 함수는 `NumberGenerator`의 구현체인 `RandomUtil`과 `TestNumberGenerator`이다.

~~~java
public class RandomUtil implements NumberGenerator {
   @Override
   public int getRandom() {
      return new Random().nextInt(10);
   }
}
~~~

실제 프로덕션 코드에서 사용될 `RandomUtil` 클래스는 랜덤 함수를 사용하여 임의의 수를 반환하는 함수로 오버라이딩했다.

~~~java
public class TestNumberGenerator implements NumberGenerator {
   public TestNumberGenerator(int number) {
      this.number = number;
   }

   @Override
   public int getRandom() {
      return number;
   }
}
~~~

반면 테스트를 목적으로 생성한 `TestNumberGenerator`는 파라미터로 정수형을 전달받아서 해당 수를 넘겨주는 역할로 오버라이딩을 했다. 이렇게 해야지만 예측(expected)과 실제 동작(actual)이 어떻게 이뤄지는지를 테스트로 비교할 수 있을것으로 판단했다.

이렇게 인터페이스를 사용해서 GameRule 클래스의 DI를 적용했는데, 이게 전략 패턴에 해당한다. 인터페이스를 사용해서 전략 패턴을 구현할 경우 OCP의 특징인 확장성은 넓힐수 있으면서 수정은 닫힌 특징을 구현할 수 있다.

<br>

# 4장. 예외

## 예외의 종류와 특징

![](https://user-images.githubusercontent.com/33862991/109124335-2719dd80-778e-11eb-81f4-089b5b82c1f5.png)

### Error

에러는 애플리케이션이 동작하는 과정에서 개발자가 예측할 수 없었던 이벤트로 인해 서비스 장애가 발생하는 현상을 의미한다. JVM에서 발생시킨다. 이는 애플리케이션 레벨이 아니라 시스템 레벨에서 신경써야 하는 영역이다.

### Exception

예외는 개발자가 예측할 수 있는 상황에 의해 발생되며 JVM에서 애플리케이션을 종료시킨다.

![](https://user-images.githubusercontent.com/33862991/109126356-80830c00-7790-11eb-9670-d4f315862885.png)

예외는 크게 CheckedException과 UncheckedException으로 구분되는데, 컴파일에서 체크할 수 있는지 여부에 따라 나뉘어진다.

### CheckedException

`CheckedException`은 컴파일시 체크되는 예외들이다. 따라서 IDE에서 개발을 하면서 CheckedException이 예상되는 지역에서 IDE에서 미리 알려주기 때문에 일단 컴파일되어 애플리케이션이 동작중이라면 본 `CheckException`을 마주할 상황은 없다.

주요 CheckedException

- `IOException`
- `ParseException`

### UncheckedException

반면 `UncheckedException`은 컴파일시 체크되지 않는 예외들이다. 흔히 `RuntimeException`을 상속받는 예외객체들이 이 `UncheckedException`에 해당한다고 보면된다.

이 예외들은 컴파일 단계에서 찾을 수 없고, 컴파일 이후 런타임 시점에 발생되어 `RuntimeException` 이 발생될 수 있다는 특징이 있다.

주요 `UncheckedException`

- `NullPointerException`
- `ArrayIndexOutOfBoundsException`
- `NumberFormatException`
- `ArithmeticException`

## 커스텀 예외 생성 방법

계좌 잔액보다 큰 금액이 이체될때 던질 예외를 커스텀하게 만든 예제코드이다.

~~~java
public class BalanceInsuffientException extends Exception {
   public BalanceInsuffientException(String message){
      super(message);
   }
}
~~~

이렇게 만든 커스텀 예외가 사용되는 코드이다.

~~~java
public class Account {
   private int 계좌;
   private int 출금액;
   
   public Account(int 계좌, int 출금액){
      this.계좌 = 계좌;
      this.출금액 = 출금액;
  }
  
   public void transfer(int account, tranferMoney) {
      if(account<transferMoney){
         throw new BalanceInsuffientException("잔고 부족!!");
      }
      계좌 -= 출금액;
      System.out.println("정상적으로 이체 성공!!");
   }
}
~~~

## 예외처리 방법

### 예외복구

클라이언트에게 Exception이 던져지기 전에 Exception이 발생할것 같은 지점에서 다른 기능을 동작시키는 것이다.

예를들면, 네트워크 접속이 원활하지 않는 곳에서 예외가 발생했을 경우 일정시간 기다렸다가 다시 접속을 시도해봄으로써 예외상황으로부터 복구를 시도했다고 할 수 있다.

### 예외처리 회피

예외가 발생할때 그 책임을 예외가 발생한 지점이 아닌 자신을 호출한 쪽으로 예외를 던지는(`throws`) 방식이다.

~~~java
public void add() throws SQLException {
   // JDBC API
}
~~~

 ~~~java
public void add() throws SQLException {
   try {
      // JDBC API
   } catch (SQLException e){
      throw e;
   }
}
 ~~~

<br>

`JdbcContext`나 `JdbcTemplate`이 사용하는 콜백 오브젝트는 메소드 선언을 보면 알겠지만 `ResultSet`이나 `PreparedStatement`등을 이용하여 작업하다 발생하는 `SQLExeption`을 자신이 처리하지 않고 템플릿으로 던져버린다.

하지만 이는 무책임한 회피가 될 수 있다. 예외에 대응하기보다는 책임을 회피함으로써 결국 호출부에게 예외를 넘기는것이므로 이는 완전한 해결책이 될 수 없다.

### 예외 전환

예외 전환 역시 호출부로 예외를 메소드 밖으로 던진다는 측면에서는 예외처리 회피와 비슷하나 발생한 예외를 그대로 넘기는게 아니라 **<u>적절한 예외로 전환</u>**해서 던진다는 특징이 있다.

예를 들어 사용자를 추가하는 DAO 메소드에서 ID가 중복되어 발생한 예외인데, 그냥 `SQLException`을 메소드밖으로 던지면, 예외가 왜 발생했는지 알 수 없다. 따라서 이 땐 `DuplicateUserIdException`이라는 커스텀 예외를 만들어서 던지면 더 직관적일 수 있다.

~~~java
public void add(User user) throws UplicateUserIdException, SQLException {
   try {
      // JDBC 이용하여 user 정보를 DB에 추가하는 코드
      // SQLException을 던지는 메소드를 호출하는 코드
   } catch(SQLException e){
      if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY){
         throw DuplicationUserIdException();
      } else {
         throw e;
      }
   }
}
~~~

보통 이렇게 예외를 전환해서 던질때에는 원래 발생한 예외와 함께 중첩 예외로 만드는 것이 좋다고 한다. 이 땐 예외객체의 `initCause()` 메소드를 호출해서 던져주면 된다.

~~~java
throw DuplicationUserIdException().initCause(e);
~~~

## 스프링 JdbcTemplate의 예외처리 전략

DAO에서 발생하는 SQLException은 애플리케이션 레벨에서 복구할 수 없는 예외이다. 따라서 이 경우에는 `throws` 키워드로 책임을 회피하기 보다는 런타임 예외(**UncheckedException**)으로 <mark>전환</mark>시켜야 한다.

스프링 JdbcTemplate는 이 예외처리 전략을 따르고 있다. JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 `SQLException`을 런타임 예외인 `DataAccessException`으로 <mark>포장</mark>해서 던져준다. 그래서 JdbcTemplate을 사용하는 UserDao 메소드에선 꼭 필요한 경우에만 `DataAccessException`(런타임 예외)를 잡아서 처리하면 되고 그 외는 무시해도 좋다. 그래서 UserDao에서 `throw SQLException`을 하지 않아도 된 것이다. 

**JdbcTemplate 적용 전**

~~~java
public void deleteAll() throws SQLException {
   this.jdbcContext.executeSql("delete from users");
}
~~~

**JdbcTemplate 적용 후**

~~~java
public void deleteAll(){
   this.jdbcTemplate.update("delete from users");
}
~~~

## JDBC의 한계

JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공한다. 내부 구현은 DB마다 조금씩 다르지만, JDBC의 API 사용법만 익숙하다면 어떤 DB든 개발자가 개발하기 용이하다고 할 수 있다. JDBC는 이렇게 자바와 DB간의 상호호완적인 인터페이스라고 할 수 있다.

### 특정 DB에 의존하는 DAO

여기서 문제는 SQL을 다루는 DAO가 특정 DB에 종속될 수 있다는 점이다. 특정 DB에서만 사용되는 명령어를 사용할 경우 해당 DAO는 특정 DB일 경우에만 동작하고 그렇지않은경우에는 `SQLException`이 발생할 수 있다.

### 호환성이 부족한 SQLException 정보

DAO에서 발생할 수 있는 예외는 다양할 수 있다. key가 중복되었거나 제약조건을 위배한다거나 테이블이나 필드가 존재하지 않을 수 있다. 그러나 JDBC는 이 모든 상황을 `SQLException` 예외 하나로 던진다.

`SQLException`이 발생하면 `getErrorCode()`로 에러코드를 가져올 수 있지만 이 에러코드또한 DB마다 상이하기 때문에 DB를 바꿀경우 이 예외코드는 동작하지 않는다. 

그래서 SQLException은 DB 상태를 가져올 수는 `getSQLState()`가 존재하는데, JDBC에서 이를 정확하게 전달해주지 않기 때문에 이 역시 유연한 예외코드를 만드는데에 어려움이 있다. 

## JdbcTemplate의 해결

JdbcTemplate는 `SQLException`을 단지 런타임 예외인 `DataAccessException`으로 포장해서 던지는게 아니라 DB의 에러코드를 `DataAccessException` 계층구조의 클래스 하나로 매핑해준다.

`DataAccessException`은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화한다. 예를 들어 JDBC, JPA, Hibernate에 상관없이 데이터 액세스 기술을 부정확하게 사용했을때 `InvalidDataAccessResourceUsageException` 예외가 던져진다. 

이를 다시 구체적으로 세부분화하면 JDBC에서 발생할 수 있는 `BadSqlGrammarException`, Hibernate에서 발생할 수 있는 `HibernateQueryException`, 잘못된 타입을 사용하려고 했을때 발생하는 `TypeMismatchDataAccessException` 등으로 구분된다.

JdbcTemplate에서 사용하는 `DataAccessException`은 `SQLException` 객체의 인터페이스같은 역할을 수행한다. Jpa를 쓰던 Jdbc를 쓰던 `DataAccessException`을 통해 `SQLException`을 처리할 수 있다.

## 4장 정리

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미없는 `throws`는 지양해야 한다.
- 예외는 예외를 복구하거나 예외처리 객체로 의도적으로 전달, 또는 적절한 예외로 전환해야 한다.
- 의미있는 예외로 포장하거나 불필요한 catch/throws 대신 런타임예외로 포장하는 두가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 런타임예외로 전환해야 한다.
- 애플리케이션의 로직을 담기위한 예외는 체크 예외로 만든다.
- JDBC의 SQLException은 대부분 복구불가능한 예외이므로 런타임 예외로 포장한다.
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용가능한 추상화된 런타임 예외계층 제공한다.
- DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 관련한 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.

# 6장. AOP

인터페이스 Calculator를 구현하는 2가지 구현체가 있다고 가정해보자.

~~~java
public interface Calculator {
   long factorial(long num);
}
~~~

~~~java
public class CalculatorImpl implements Calculator {
   @Override
   public long factorial(long num) {
      long result = 1;
      for (int i = 1; i <= num; i++) {
         result *= i;
      }
      return result;
   }
}
~~~

~~~java
public class RecCalculator implements Calculator {
   @Override
   public long factorial(long num) {
      if(num==0) {
         return 1;
      } else {
         return num * factorial(num-1);
      }
   }
}
~~~

이 때 프로그램 실행시간을 측정하는 코드를 주입하고자 한다. 

~~~java
long start = System.nanoTime();
long end = System.nanoTime();
System.out.println("소요 시간 : "+(end-start));
~~~

이 코드는 프로그램 실행 전과 후에 각각 주입해서 프로그램이 종료되면 시간을 계산해서 출력하는 코드이다. 

`CalculatorImpl`에 적용하는건 어려워보이지 않는다. 그런데 `RecCalculator`는 재귀함수이기 때문에 불필요하게 콘솔 출력문이 여러번 출력될 수 있다. 이 땐 어떻게 해야할까?

직접 로직에 주입하는게 아니라 인스턴스 호출부에서 시간을 측정해야할 것 같다.

~~~java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class CalculatorTest {
   @Test
   @DisplayName("Calculator 시간 주입 테스트")
   void proxy2() {
      // given
      int num = 4;

      int expected = 1;
      for (int i = 1; i <= num; i++) {
         expected *= i;
      }

      // when
      CalculatorImpl calcImpl = new CalculatorImpl();
      long start1  = System.nanoTime();
      long factorial1 = calcImpl.factorial(num);
      long end1 = System.nanoTime();
      System.out.printf(calcImpl.getClass().getSimpleName()+" 실행 시간 = %d\n", num, (end1-start1));

      RecCalculator calcRec = new RecCalculator();
      long start2  = System.nanoTime();
      long factorial2 = calcRec.factorial(num);
      long end2 = System.nanoTime();
      System.out.printf(calcRec.getClass().getSimpleName()+" 실행 시간 = %d\n", num, (end2-start2));

      // then
      assertEquals(expected, calcImpl.factorial(num));
      assertEquals(expected, calcRec.factorial(num));
   }
}
~~~

그런데 코드가 깔끔하지 않다. 시간을 측정하는 코드가 중복되는데 이 중복은 어떻게 제거할 수 있을까?

`CalculatorImpl`과 `RecCalculator`는 같은 인터페이스(`Calculator`)를 구현하는 객체이다. 이걸 이용하면 아래와 같이 해볼 수 있을것 같다.

~~~java
public class ProxyCalculator implements Calculator {
   private Calculator delegate;

   public ExeTimeCalculator(Calculator delegate) {
      this.delegate = delegate;
   }

   @Override
   public long factorial(long num) {
      long start = System.nanoTime();
      long result = delegate.factorial(num);
      long end = System.nanoTime();
      System.out.printf("%s.factorial(%d) 실행 시간 = %d\n",
         delegate.getClass().getSimpleName(),
         num, (end-start));
      return result;
   }
}
~~~

외부에서 `Calculator` 객체를 주입받아서 인스턴스로부터 `factorial()`을 호출하는 방식을 이용하니 중복코드를 제거할 수 있었다.

실제 정상적으로 작동하는지 테스트 코드를 작성했다.

~~~java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class ProxyCalculatorTest {
   @Test
   @DisplayName("proxy 테스트")
   void proxy() {
      // given
      int num = 4;

      int expected = 1;
      for (int i = 1; i <= num; i++) {
         expected *= i;
      }

      // when
      ExeTimeCalculator proxy = new ExeTimeCalculator(new RecCalculator());

      // then
      assertEquals(expected, proxy.factorial(num));
   }
}
~~~

<br>

### 왜 ExeTimeCalculator는 Calculator를 implements한걸까

다시 `ProxyCalculator` 코드를 보면, 사실 `Calculator`를 상속받지 않아도 될 코드임을 알 수 있다. `factorial()`을 오버라이딩하긴 하였지만, 사실 상속받지 않고, 오버라이딩하지 않아도 결과는 똑같이 가져올 수 있다. 그러나 왜 `Calculator`를 상속한걸까?

기능 분리를 위함이었다고 생각된다. `ProxyCalculator`는 `Calculator` 구현체들에게 기능을 주입하는 역할과 책임이 있다. 따라서 이 객체를 `Calculator`를 구현하는 클래스로 만듦으로써 같은 관심사를 갖는 객체끼리 묶을 수 있다는 특징이 있었다. 이것을 AOP라 한다.

이제 AOP와 관련한 용어를 살펴보자.

### Aspect

흩어진 관심사를 모듈화한 것. AOP로 구현하는 <span style="color: red;">공통기능</span>이 Aspect에 해당한다.

트랜잭션이나 보안등이 Aspect의 예이다.

### Target

Aspect를 적용하는 곳에 해당된다. (클래스, 메소드)

위의 예제 코드에서 `CalculatorImpl`, `RecCalculator`가 Target(대상 객체)에 해당한다.

### JointPoint

Advice가 적용될 위치, 메소드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올때 등 다양한 시점에 적용 가능

### Advice

Aspect(공통 관심기능)을 어느 위치(JoinPoint)에 적용할지를 정의한다.

> 메소드를 호출하기 전 (언제) 트랜잭션 시작(공통기능)을 적용한다는 것을 정의

특정 jointPoint의 Aspect에 의한 동작을 의미한다. 대상 객체의 JointPoint에 Weaving되어 동작할 수 있는 코드를 의미한다.

### PointCut

JoinPoint의 부분집합으로써 실제 Advice가 적용되는 JoinPoint를 나타낸다. 

스프링에서는 정규표현식이나 AspectJ의 문법을 이용하여 PointCut을 정의할 수 있다.

### Weaving

Aspect를 핵심 로직 코드에 적용하는 것을 Weaving이라 한다.

Aspect를 대상 객체에 연결시켜 관점지향 객체로 만드는 과정을 의미. (Advice를 비즈니스 로직에 삽입하는 것을 의미)

### Proxy

Target을 감싸서 요청을 대신 받아주는 랩핑 클래스를 의미한다.

위의 예제코드에서 `ProxyCalculator` 클래스가 Proxy에 해당한다.

### 프록시 패턴

어떠한 일을 대신 처리하는 패턴을 의미한다. 프록시(Proxy)는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다면, 프록시 패턴은 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우이다.

참고 글 : [코딩팩토리 - 프록시 패턴에 대하여](https://coding-factory.tistory.com/711)

### 데코레이터 패턴

타깃에 부가적인 기능을 런타임시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴. 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점에서 어떤 방법과 순서로 프록시와 타깃이 연결되는지를 정하지않는다는 의미이다.

객체의 결합을 통해 기능을 동적으로 유연하게 확장해주는 패턴이다. 위의 예제코드를 통해 구현한 AOP는 사실 데코레이터 패턴에 가까운 방식이다.

참고 글 : [hee's development - 데코레이터 패턴이란](https://gmlwjd9405.github.io/2018/07/09/decorator-pattern.html)

### 데코레이터 객체와 프록시의 차이

데코레이터 객체가 기능 추가와 확장에 초점이 맞춰져있는 객체라면, 프록시는 접근 제어 관점에만 초점이 맞춰져있다.

위의 예제코드에서 `CalculatorImpl`이나 `RecCalculator`는 팩토리얼의 핵심 로직을 직접 구현하고 있다. `ProxyCalculator`는 실행시간 측정이라는 공통 기능 구현을 집중했기 때문에 `ProxyCalculator` 역시 데코레이터 객체라고 할수도 있다.

어쨋든 `ProxyCalculator`을 통해서 공통기능 구현과 핵심 기능 구현을 분리할 수 있었는데, 이것이 AOP의 핵심 개념이다.

<mark>AOP의 핵심 개념은 핵심 기능에 공통 기능을 삽입하는 것</mark>이라고 한다. 핵심 기능에 공통 기능을 삽입하는 방법은 다음 세가지가 있다.

- 컴파일 시점에 코드에 공통 기능을 삽입하는 방법
- 클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입하는 방법
- 런타임에 <span style="color: red;">프록시 객체</span>를 생성해서 공통기능을 삽입하는 방법

스프링에서 제공하는 AOP는 <span style="color: red;">프록시</span>를 이용한 세번째 방식이다. 

